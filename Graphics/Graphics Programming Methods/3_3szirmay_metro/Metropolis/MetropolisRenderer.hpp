// Graphics Programming Methods
// Metropolis sampling in global illumination
// György Antal, Lászlo Szirmay-Kalos
// 2003.

// Implementation of the Metropolis Light Transfer Algorithm (see paper)

#pragma once

#include <stack>
#include "Scene.hpp"
#include "Metropolis.hpp"

#define RAND  ((double)rand () / (RAND_MAX + 1))	
const short MaxPathVerts = 8;	// maximum number of the vertices for a path, it can be arbitrary large

// PathNode represents a vertex in the path
//-----------------------------------------------------------------
class PathNode
{
public:
	HitRec		m_hit;			// information on the intersection point returned by the kd-tree
	Vector		m_inDirTo;		// incoming direction

	double		m_GfromPrev;	// geometric coefficient for the energy transport
	double		m_pdfFromPrev;	// generation probability of the vertex
	Color		m_bsdfEval;		// brdf at surface point
};

// Path represents a light path
// the 0. vertex is always the eye
// the last vertex is always the light source
//-----------------------------------------------------------------
class Path {
public:
	PathNode	verts[MaxPathVerts];// the vertices of the path
	long		nVerts;				// the number of the vertices
	short		nx, ny;				// x and y-coordinate of the pixel in which this path gone through
	Color		radiance;			// the radiance contribution of the path
	double		I;					// the importance of the path
	double		pdfGen;				// the generation probability of the full path (vertex by vertex)
	long		nUsedRandCoords;	// the number of the random coordinates associated with the path
	bool		large_step;			// this path is generated by large step or not

	Path() {
		nVerts = 0;
	}
};

// PrimaryCoord respresents a coordinate of the sampe in the primary sample space
//-----------------------------------------------------------------
class PrimaryCoord {
public:
	unsigned long	modifyTime;		// the last modification time of the primary coordinate
	double			value;			// the random value primary coordinate
};

// MetropolisRenderer is the class which performs the Metropolis rendering
//-----------------------------------------------------------------
class MetropolisRenderer {
	const Scene*	scene;				// the scene (triangles, lights, camera, etc.)
	Image*			image;				// the calculated image
	long			rayId;				// the unique identifier of a ray for the kd-tree algorithm

	short			samplesPerPixel;	// the number of path per pixel
	unsigned long	M;					// total number of ray samples
	double			pLarge;				// the probability that we generate a totally new path instead of perturbing the previous one
	double			maxMutationDist;	// max. distance of the perturbed and the original coordinate in the primary space
	short			maxFollowedVerts;	// cut the recursion depth if needed

	long			nSeedPaths;			// number of seed paths for the first phase of the MLT
	Path*			seedPaths;			// seed paths for the first phase of the MLT

	Path			oldPath, newPath;	// newPath == candidatePath, oldPath == currentPath
	PathNode		eyeNode;			// precalculated for oldPath, newPath
	long			nAcceptedMutations, nRejectedMutations;	// number of accepted and rejected samples

	// lazy evalutation of the coordintates
	unsigned long				time;				// current time stamps
	unsigned long				large_step_time;	// the last time when large step was performed
	PrimaryCoord				u[3 * MaxPathVerts];// the primary sample in the primary sample space
	std::stack<PrimaryCoord>	uStack;				// stack of coordinates for lazy evaluation (see paper)

	void	EyePointSample	(void);		// generate the 0. vertex of the path
	bool	PixelSample		(void);		// generate the 1. vertex of the path
	bool	SurfaceSample	(void);		// generate one in-between vertex of the path
	bool	LightSample		(void);		// generate the last vertex of the path
	void	TraceEyePath	(void);		// generate the subpath of the path by iteratively calling SurfaceSample()

	bool	GenerateNewPath (void);		// generate the 'newPath' by generating vertices
	void	ContributePath	(const Path& path, double weight);	// update the pixel of the image affected by the path

	float	MutateValue		(float value);	// mutate a coordinate randomly in [0..1]
	float	PrimarySample	(short i);		// lazy evaluation of a coordinate in the primary sample space

public:
	MetropolisRenderer(const Scene* pScene, short gSamplePerPixel, Image* pImage);
	~MetropolisRenderer() {};
	bool RenderMLT(void);		// perform the Metropolis Light Transport rendering algorithm
};


