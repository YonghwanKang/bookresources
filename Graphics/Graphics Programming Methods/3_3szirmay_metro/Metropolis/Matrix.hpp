// Graphics Programming Methods
// Metropolis sampling in global illumination
// György Antal, Lászlo Szirmay-Kalos
// 2003.

#pragma once
#include <assert.h>
#include <float.h>

// the Matrix class represents a 3x3 matrix
//-----------------------------------------------------------------
class Matrix {
public:
	float m[3][3];		// matrix values

	Matrix() {}
	Matrix(float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22){
		m[0][0] = m00;
		m[0][1] = m01;
		m[0][2] = m02;

		m[1][0] = m10;
		m[1][1] = m11;
		m[1][2] = m12;

		m[2][0] = m20;
		m[2][1] = m21;
		m[2][2] = m22;
	}

	inline Matrix Invert(void);
	inline Vector MultiplyMatrixLeft(const Vector& vIn);	// return (Matrix * vIn)
};

// invert the matrix in place
//-----------------------------------------------------------------
Matrix Matrix::Invert(void)
{
	// generated by maple  C(A_inv,optimized);       
	float		t4 = m[0][0]*m[1][1];
	float 	    t6 = m[0][0]*m[1][2];
	float 	    t8 = m[0][1]*m[1][0];
	float 	    t10 = m[0][2]*m[1][0];
	float 	    t12 = m[0][1]*m[2][0];
	float 	    t14 = m[0][2]*m[2][0];
	float 	    t17 = 1/(t4*m[2][2]-t6*m[2][1]-t8*m[2][2]+t10*m[2][1]+t12*m[1][2]-t14*m[1][1]);

	assert (!_isnan (t17));
	Matrix result;
	result.m[0][0] = (m[1][1]*m[2][2]-m[1][2]*m[2][1])*t17;
	result.m[0][1] = -(m[0][1]*m[2][2]-m[0][2]*m[2][1])*t17;
	result.m[0][2] = -(-m[0][1]*m[1][2]+m[0][2]*m[1][1])*t17;
	result.m[1][0] = -(m[1][0]*m[2][2]-m[1][2]*m[2][0])*t17;
	result.m[1][1] = (m[0][0]*m[2][2]-t14)*t17;
	result.m[1][2] = -(t6-t10)*t17;
	result.m[2][0] = -(-m[1][0]*m[2][1]+m[1][1]*m[2][0])*t17;
	result.m[2][1] = -(m[0][0]*m[2][1]-t12)*t17;
	result.m[2][2] = (t4-t8)*t17;
	return result;
}

// vOut = Matrix * vIn,  matrix is on the left side
//-----------------------------------------------------------------
inline Vector Matrix::MultiplyMatrixLeft (const Vector& vIn)
{
	return Vector(	vIn.x * m[0][0] + vIn.y * m[0][1] + vIn.z * m[0][2],
					vIn.x * m[1][0] + vIn.y * m[1][1] + vIn.z * m[1][2],
					vIn.x * m[2][0] + vIn.y * m[2][1] + vIn.z * m[2][2]);
}