<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>KDTree.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>KDTree.cpp</h1><a href="KDTree_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// Graphics Programming Methods</span>
00002 <span class="comment">// An Effective kd-tree Implementation</span>
00003 <span class="comment">// László Szécsi</span>
00004 <span class="comment">// 2003.</span>
00005 
00006 <span class="comment">// implementation of kd-tree methods</span>
00007 
00008 <span class="preprocessor">#include "<a class="code" href="KDTree_8hpp.html">KDTree.hpp</a>"</span>
00009 <span class="preprocessor">#include &lt;iostream&gt;</span>
00010 
00011 <span class="preprocessor">#pragma warning( disable : 4311 )               // 'type cast' : pointer truncation from 'unsigned int *' to 'unsigned int'</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4312 )               // 'type cast' : conversion from 'unsigned int' to 'float *' of greater size</span>
00013 <span class="preprocessor"></span>
<a name="l00014"></a><a class="code" href="classKDTree.html#a2">00014</a> <span class="keywordtype">bool</span> <a class="code" href="classKDTree.html#a2">KDTree::traverse</a> (<span class="keyword">const</span> <a class="code" href="classRay.html">Ray</a>&amp; ray, <a class="code" href="classHitRec.html">HitRec</a>&amp; hitRec, <span class="keywordtype">float</span> minT, <span class="keywordtype">float</span> maxT)
00015 {
00016         <span class="comment">// handle dirs parallel to axis here in advance</span>
00017         <span class="comment">// will not need to check later for every node;</span>
00018         <a class="code" href="classVector.html">Vector</a> dirInverts;
00019         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;3; i++) {
00020                 dirInverts[i] = 1.0f / ray.<a class="code" href="classRay.html#m1">dir</a>[i];
00021         }
00022 
00023         hitRec.<a class="code" href="classHitRec.html#m2">object</a>   = NULL;
00024         hitRec.<a class="code" href="classHitRec.html#m3">isIntersect</a> = <span class="keyword">false</span>;
00025         hitRec.<a class="code" href="classHitRec.html#m1">depth</a> = FLT_MAX;
00026 
00027         <span class="keywordtype">float</span> rayMin = minT;
00028         <span class="keywordtype">float</span> rayMax = maxT;
00029 
00030         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tNode = 0;
00031         <span class="keywordtype">signed</span> <span class="keywordtype">int</span> stackPointer = -1;
00032 
00033         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leftChild;
00034         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rightChild;
00035 
00036         <span class="keywordflow">for</span>(;;)
00037         {
00038                 <span class="keywordtype">bool</span> <a class="code" href="classKDTree.html#c6">isLeaf</a> = !<a class="code" href="classKDTree.html#c7">followChildren</a>(tNode, leftChild, rightChild);
00039 
00040                 <span class="keywordflow">if</span>(isLeaf) <span class="comment">// node is a leaf</span>
00041                 { 
00042                         <a class="code" href="classIntersectable.html">Intersectable</a>** leafList = ((<a class="code" href="classIntersectable.html">Intersectable</a>***)<a class="code" href="classKDTree.html#o6">nodeTable</a>)[tNode];
00043                         <span class="keywordflow">if</span>(leafList) <span class="comment">// leaf contains some objects</span>
00044                         {
00045                                 <span class="comment">// first 4 bytes of leafList contains the length</span>
00046                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leafListLength = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)*leafList;
00047                                 <a class="code" href="classIntersectable.html">Intersectable</a>** leafListEnd = ++leafList + leafListLength;
00048                                 <span class="keywordflow">for</span> (<a class="code" href="classIntersectable.html">Intersectable</a>** objectIterator = leafList; objectIterator &lt; leafListEnd; objectIterator++) {
00049                                         <span class="keywordtype">float</span> <a class="code" href="classKDTree.html#o11">depth</a>;
00050                                         <span class="comment">// check if this test was already done</span>
00051                                         <span class="keywordflow">if</span> (ray.<a class="code" href="classRay.html#m2">id</a> != (*objectIterator)-&gt;lastTestedRayId) 
00052                                                 (*objectIterator)-&gt;intersect (ray, depth);
00053                                         <span class="keywordflow">else</span>
00054                                                 depth = (*objectIterator)-&gt;lastTestedRayResult.depth;
00055                                         <span class="comment">// intersection is acceptable only if it is within the node volume</span>
00056                                         <span class="keywordflow">if</span> ((*objectIterator)-&gt;lastTestedRayResult.isIntersect &amp;&amp; 
00057                                                         depth &lt; hitRec.<a class="code" href="classHitRec.html#m1">depth</a> &amp;&amp;
00058                                                         depth &gt; rayMin - <a class="code" href="classKDTree.html#o13">epsilon</a> &amp;&amp;
00059                                                         depth &lt; rayMax + <a class="code" href="classKDTree.html#o13">epsilon</a>
00060                                                         )
00061                                                 hitRec = (*objectIterator)-&gt;lastTestedRayResult;
00062                                 }
00063                         
00064                                 <span class="keywordflow">if</span>(hitRec.<a class="code" href="classHitRec.html#m3">isIntersect</a>)
00065                                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00066                                 <span class="keywordflow">else</span>
00067                                         <span class="keywordflow">if</span>(stackPointer &gt;= 0) 
00068                                         { 
00069                                                 <span class="comment">//have not found anything on this branch, pop the other one from stack</span>
00070                                                 rayMin = <a class="code" href="classKDTree.html#o10">traverseStack</a>[stackPointer].<a class="code" href="structKDTree_1_1TraverseStack.html#m0">rayMin</a>;
00071                                                 rayMax = traverseStack[stackPointer].rayMax;
00072                                                 tNode = traverseStack[stackPointer].tNode;
00073                                                 stackPointer--;
00074                                         }
00075                                         <span class="keywordflow">else</span>
00076                                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00077                         }
00078                         <span class="keywordflow">else</span>
00079                         {
00080                                 <span class="comment">//leaf is empty</span>
00081                                 <span class="keywordflow">if</span>(stackPointer &gt;= 0)
00082                                 {
00083                                         rayMin = <a class="code" href="classKDTree.html#o10">traverseStack</a>[stackPointer].<a class="code" href="structKDTree_1_1TraverseStack.html#m0">rayMin</a>;
00084                                         rayMax = traverseStack[stackPointer].rayMax;
00085                                         tNode = traverseStack[stackPointer].tNode;
00086                                         stackPointer--;
00087                                 }
00088                                 <span class="keywordflow">else</span>
00089                                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00090                         }
00091                 }
00092                 <span class="keywordflow">else</span> <span class="comment">//not a leaf, go deeper</span>
00093                 {
00094                         <span class="comment">// gather cutting plane information from the nodeTable</span>
00095                         <span class="keywordtype">float</span> nodeValue = <a class="code" href="classKDTree.html#o6">nodeTable</a>[tNode];
00096                         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> axis = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)(&amp;nodeValue) &amp; 0x00000003;
00097                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitfield = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)(&amp;nodeValue) &amp; 0xfffffffc;
00098                         <span class="keywordtype">float</span> cutPlane = *(<span class="keywordtype">float</span>*)(&amp;bitfield);
00099 
00100                         <span class="keywordtype">float</span> origCoord = ray.<a class="code" href="classRay.html#m0">origin</a>[axis];
00101                         <span class="keywordtype">float</span> dirCoord = dirInverts[axis];
00102 
00103             <span class="comment">// calculate cutting plane - ray intersection distance 't'</span>
00104                         <span class="keyword">register</span> <span class="keywordtype">float</span> t = (cutPlane - origCoord) * dirCoord;
00105 
00106                         <span class="comment">// find the child volume nearer to the origin</span>
00107                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nearNode = rightChild;
00108                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> farNode = leftChild;
00109                         <span class="keywordflow">if</span>(origCoord + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; cutPlane ||            <span class="comment">// origin on the left</span>
00110                                 (cutPlane + <a class="code" href="classKDTree.html#o13">epsilon</a> &gt; origCoord) &amp;&amp;             <span class="comment">// or on the plane</span>
00111                                 dirCoord &lt; 0)                                                   <span class="comment">// but dir goes left</span>
00112                         {
00113                                 nearNode = leftChild;
00114                                 farNode = rightChild;
00115                         }
00116 
00117                         <span class="keywordflow">if</span>(t &lt;= 0 || rayMax + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; t )
00118                                 <span class="comment">// whole interval on near cell</span>
00119                                 tNode = nearNode;
00120                         <span class="keywordflow">else</span>
00121                         {
00122                                 <span class="keywordflow">if</span>(t &lt; rayMin - <a class="code" href="classKDTree.html#o13">epsilon</a>)
00123                                         <span class="comment">// whole interval on far cell</span>
00124                                         tNode = farNode;
00125                                 <span class="keywordflow">else</span>
00126                                 {
00127                                         <span class="comment">// both cells</span>
00128                                         <span class="comment">// push far branch to stack</span>
00129                                         stackPointer++;
00130                                         <a class="code" href="classKDTree.html#o10">traverseStack</a>[stackPointer].<a class="code" href="structKDTree_1_1TraverseStack.html#m0">rayMin</a> = t;
00131                                         <a class="code" href="classKDTree.html#o10">traverseStack</a>[stackPointer].<a class="code" href="structKDTree_1_1TraverseStack.html#m1">rayMax</a> = rayMax;
00132                                         <a class="code" href="classKDTree.html#o10">traverseStack</a>[stackPointer].<a class="code" href="structKDTree_1_1TraverseStack.html#m2">tNode</a> = farNode;
00133                                         <span class="comment">// near branch is next to traverse</span>
00134                                         tNode = nearNode;
00135                                         rayMax = t;
00136                                 }
00137                         }
00138                 }
00139         }
00140         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00141 }
00142 
<a name="l00143"></a><a class="code" href="classKDTree.html#c0">00143</a> <span class="keywordtype">void</span> <a class="code" href="classKDTree.html#c0">KDTree::deleteLeaves</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeID)
00144 {
00145         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rc;
00146         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lc;
00147         <span class="keywordflow">if</span>(!<a class="code" href="classKDTree.html#c7">followChildren</a>(nodeID, lc, rc))
00148         {
00149                 <a class="code" href="classIntersectable.html">Intersectable</a>** leafList = *(<a class="code" href="classIntersectable.html">Intersectable</a>***)&amp;<a class="code" href="classKDTree.html#o6">nodeTable</a>[nodeID];
00150                 <span class="keywordflow">if</span>(leafList)
00151                 {
00152                         <span class="keyword">delete</span> leafList;
00153                         <span class="keywordflow">return</span>;
00154                 }
00155                 <span class="keywordflow">return</span>;
00156         }
00157         <a class="code" href="classKDTree.html#c0">deleteLeaves</a>(lc);
00158         <a class="code" href="classKDTree.html#c0">deleteLeaves</a>(rc);
00159 }
00160 
<a name="l00161"></a><a class="code" href="classKDTree.html#c7">00161</a> <span class="keywordtype">bool</span> <a class="code" href="classKDTree.html#c7">KDTree::followChildren</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; parent, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;leftChild, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;rightChild)
00162 {
00163         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subPos = parent &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>;                 <span class="comment">// position within cache line</span>
00164         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> supPos = parent &amp; ~nCacheLineNodes;                <span class="comment">// cache line index</span>
00165         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leafBit = ((*(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)&amp;<a class="code" href="classKDTree.html#o6">nodeTable</a>[parent | nCacheLineNodes]) &gt;&gt; subPos) &amp; 0x1;
00166         <span class="keywordflow">if</span>(leafBit)                                                     <span class="comment">// node is a leaf, has no children</span>
00167                 <span class="keywordflow">return</span> <span class="keyword">false</span>;                                   <span class="comment">// leftChild &amp; rightChild unchanged</span>
00168         subPos = (subPos &lt;&lt; 1) + 1;                     <span class="comment">// index of left child</span>
00169         <span class="keywordflow">if</span>(subPos &gt;= nCacheLineNodes)           <span class="comment">// out of cache line, node is pointer node</span>
00170         {
00171                 parent = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)<a class="code" href="classKDTree.html#o6">nodeTable</a>)[parent];    <span class="comment">// follow pointer</span>
00172                 subPos = parent &amp; nCacheLineNodes;                              <span class="comment">// same procedure with new parent node</span>
00173                 supPos = parent &amp; ~nCacheLineNodes;                             <span class="comment">// referenced node cannot be leaf</span>
00174                 subPos = (subPos &lt;&lt; 1) + 1;                                             <span class="comment">// or pointer node</span>
00175         }
00176         leftChild = (parent &amp; ~nCacheLineNodes) | subPos;       <span class="comment">// recombine parent and node address</span>
00177         rightChild = (parent &amp; ~nCacheLineNodes) | subPos + 1;
00178         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00179 }
00180 <span class="comment"></span>
00181 <span class="comment">//! retrieve would-have-been child nodes of a leaf node, if they are not in a last row</span>
<a name="l00182"></a><a class="code" href="classKDTree.html#c8">00182</a> <span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="classKDTree.html#c8">KDTree::getFreeNodes</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leaf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; leftFree, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; rightFree)
00183 {
00184         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subPos = leaf &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>;                   <span class="comment">// position within cache line</span>
00185         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> supPos = leaf &amp; ~nCacheLineNodes;                  <span class="comment">// cache line index</span>
00186         subPos = (subPos &lt;&lt; 1) + 1;                     <span class="comment">// index of left child position</span>
00187         <span class="keywordflow">if</span>(subPos &lt; nCacheLineNodes)            <span class="comment">// within cache line, may have free children positions</span>
00188         {
00189                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> grandSubPos = ((subPos + 1) &lt;&lt; 1) + 2;     <span class="comment">// rightmost grandchild</span>
00190                 <span class="keywordflow">if</span>(grandSubPos &gt;= nCacheLineNodes)                                      <span class="comment">// children are on last row</span>
00191                         <span class="keywordflow">return</span> <span class="keyword">false</span>;                                                                   <span class="comment">// not suitable for free nodes</span>
00192                 leftFree = (leaf &amp; ~nCacheLineNodes) | subPos;
00193                 rightFree = (leaf &amp; ~nCacheLineNodes) | subPos + 1;
00194                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00195         }
00196         <span class="keywordflow">else</span>
00197                 <span class="keywordflow">return</span> <span class="keyword">false</span>;                                   <span class="comment">// leaf is on last row, has no free children</span>
00198 }
00199 
<a name="l00200"></a><a class="code" href="classKDTree.html#c6">00200</a> <span class="keywordtype">bool</span> <a class="code" href="classKDTree.html#c6">KDTree::isLeaf</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xnode)
00201 {
00202         <span class="keywordflow">return</span> ((*(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *)&amp;<a class="code" href="classKDTree.html#o6">nodeTable</a>[xnode | <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>]) &gt;&gt; (xnode &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>)) &amp; 0x1;
00203 }
00204 
<a name="l00205"></a><a class="code" href="classKDTree.html#c4">00205</a> <span class="keywordtype">float</span> <a class="code" href="classKDTree.html#c4">KDTree::getBoundValue</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * extremeIndex, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> axis)
00206 {
00207         <span class="comment">//if Most Significant Bit of 'extremeIndex' is 1, take the maximum</span>
00208         <span class="comment">//if Most Significant Bit of 'extremeIndex' is 0, take the minimum</span>
00209         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = *extremeIndex;
00210         <span class="keywordflow">return</span> (index &amp; 0x80000000)?
00211                 (<a class="code" href="classKDTree.html#o8">objects</a>[ index &amp; 0x7fffffff]-&gt;<a class="code" href="classIntersectable.html#m1">bbox</a>.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>[axis]):
00212                 (<a class="code" href="classKDTree.html#o8">objects</a>[ index &amp; 0x7fffffff]-&gt;<a class="code" href="classIntersectable.html#m1">bbox</a>.<a class="code" href="classBoundingBox.html#m0">minPoint</a>[axis]);
00213 }
00214 
<a name="l00215"></a><a class="code" href="classKDTree.html#c1">00215</a> <span class="keywordtype">void</span> <a class="code" href="classKDTree.html#c1">KDTree::build</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeID, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* boundsArray, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nObjects, <a class="code" href="classBoundingBox.html">BoundingBox</a>&amp; limits, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> axisNmask)
00216 {
00217         <span class="comment">//separate the axisNmask parameter to axis and mask</span>
00218         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> axis = axisNmask &amp; 07;
00219         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask = axisNmask &amp; 070;
00220 
00221         <span class="comment">//calculate some values for the cost function</span>
00222         <span class="keywordtype">float</span> costBase;         <span class="comment">// area of face perpendicular to axis</span>
00223         <span class="keywordtype">float</span> costSteep;        <span class="comment">// half of circumference of face perpendicular to axis</span>
00224                                                 <span class="comment">// surface area / 2 = costBase + costSteep * (length of edge parallel to axis)</span>
00225                                                 <span class="comment">// cost = #(objects within volume) * surface area / 2</span>
00226         <span class="keywordflow">switch</span>(axis)
00227         {
00228         <span class="keywordflow">case</span> 0:
00229                 costBase = (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m3">z</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m3">z</a>)
00230                                         *       (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m2">y</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m2">y</a>);
00231                 costSteep = (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m3">z</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m3">z</a>)
00232                                         +       (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m2">y</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m2">y</a>);
00233                 <span class="keywordflow">break</span>;
00234         <span class="keywordflow">case</span> 1:
00235                 costBase = (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m1">x</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m1">x</a>)
00236                                         *       (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m3">z</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m3">z</a>);
00237                 costSteep = (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m1">x</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m1">x</a>)
00238                                         +       (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m3">z</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m3">z</a>);
00239                 <span class="keywordflow">break</span>;
00240         <span class="keywordflow">case</span> 2:
00241                 costBase = (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m1">x</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m1">x</a>)
00242                                         *       (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m2">y</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m2">y</a>);
00243                 costSteep = (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m1">x</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m1">x</a>)
00244                                         +       (limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m2">y</a> - limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m2">y</a>);
00245                 <span class="keywordflow">break</span>;
00246         }
00247 
00248         <span class="comment">// references to extrema (corresponding to 'axis') of node volume</span>
00249         <span class="keywordtype">float</span>&amp; limiMin = axis?((axis==1)?limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m2">y</a>:limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m3">z</a>):limits.<a class="code" href="classBoundingBox.html#m0">minPoint</a>.<a class="code" href="classVector.html#m1">x</a>;
00250         <span class="keywordtype">float</span>&amp; limiMax = axis?((axis==1)?limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m2">y</a>:limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m3">z</a>):limits.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>.<a class="code" href="classVector.html#m1">x</a>;
00251 
00252         <span class="comment">//sort the the extrema of the objects</span>
00253         <span class="comment">//we will need this to find the best splitting plane</span>
00254         <a class="code" href="classKDTree.html#c2">quickSort</a>(boundsArray, boundsArray + (nObjects &lt;&lt; 1) - 1, axis);
00255 
00256         <span class="comment">// the following code section could be used to find the spatial and object medians</span>
00257         <span class="comment">// either to implement a simpler and less effective subdivision rule</span>
00258         <span class="comment">// or to restrict optimum search to the median interval (between two median)</span>
00259         <span class="comment">//***************************************************************************</span>
00260         <span class="comment">// find the value for the spatial median.... easy</span>
00261         <span class="comment">//      float spatialMedian = (limiMax + limiMin) / 2.0f;</span>
00262         <span class="comment">//find the position in the array corresponding to the spatial median value</span>
00263         <span class="comment">//      unsigned int* spatialMedianPosition = findBound(boundsArray, nObjects &lt;&lt; 1, spatialMedian, axis);</span>
00264         <span class="comment">//find object median position (middle of array, surprise-surprise), and value</span>
00265         <span class="comment">//      unsigned int* objectMedianPosition = boundsArray + nObjects;</span>
00266         <span class="comment">//      float objectMedian = getBoundValue(objectMedianPosition, axis);</span>
00267         <span class="comment">//****************************************************************************</span>
00268 
00269         <span class="comment">// find the value for the left and right "cutting off empty space" (COES) planes </span>
00270         <span class="comment">// remember the object extrema are already sorted</span>
00271         <span class="keywordtype">float</span> leftCoesCut = <a class="code" href="classKDTree.html#o8">objects</a>[boundsArray[0] &amp; 0x7fffffff]-&gt;<a class="code" href="classIntersectable.html#m1">bbox</a>.<a class="code" href="classBoundingBox.html#m0">minPoint</a>[axis];
00272         <span class="keywordtype">float</span> rightCoesCut = objects[boundsArray[(nObjects &lt;&lt; 1)-1] &amp; 0x7fffffff]-&gt;bbox.maxPoint[axis];
00273 
00274         <span class="keywordflow">if</span>(rightCoesCut &gt; limiMax)
00275                 rightCoesCut = limiMax;
00276         <span class="keywordflow">if</span>(leftCoesCut &lt; limiMin)
00277                 leftCoesCut = limiMin;
00278 
00279         <span class="comment">// find the estimated cost of ray casting after COES</span>
00280         <span class="keywordtype">float</span> leftCoesCutCost = ((limiMax - leftCoesCut) * costSteep + costBase) * (nObjects);
00281         <span class="keywordtype">float</span> rightCoesCutCost = ((rightCoesCut - limiMin) * costSteep + costBase) * (nObjects);
00282         <span class="comment">// take care of numerical accuracy problems that arise when</span>
00283         <span class="comment">// limiMin == limiMax           (possible and allowed)</span>
00284         <span class="keywordflow">if</span>(leftCoesCutCost &lt; 0) leftCoesCutCost = FLT_MAX;
00285         <span class="keywordflow">if</span>(rightCoesCutCost &lt; 0) rightCoesCutCost = FLT_MAX;
00286 
00287         <span class="comment">// creep through array, evaluate cost for every possible cut,</span>
00288         <span class="comment">// maintaining the counters for intersected and completely passed objects</span>
00289         <span class="keywordtype">int</span> leftCount = 0;                              <span class="comment">// objects on the left of current cut</span>
00290         <span class="keywordtype">int</span> intersectedCount = 0;               <span class="comment">// object intersected by current cut</span>
00291 
00292         <span class="comment">// we may limit the search to a partition of the array, eg. the median interval</span>
00293         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* searchIntervalStart;
00294         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* searchIntervalEnd;
00295 
00296         <span class="comment">// full range optimum search</span>
00297         searchIntervalStart = boundsArray + 1;
00298         searchIntervalEnd = boundsArray + (nObjects &lt;&lt; 1) - 1;
00299 
00300         <span class="comment">// these three variable identify the best cut found so far:</span>
00301         <span class="keywordtype">float</span> minimumCostFound;
00302         <span class="keywordtype">float</span> minimumCostCut;
00303         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* minimumCostPosition;
00304 
00305         <span class="comment">// is left or right COES better? the better is our best candidate to start with</span>
00306         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minimumIntersected = 0;
00307         <span class="keywordtype">int</span> minimumLeft = 0;
00308         <span class="keywordflow">if</span>(leftCoesCutCost &lt; rightCoesCutCost)
00309         {
00310                 minimumCostFound = leftCoesCutCost;
00311                 minimumCostPosition = boundsArray;
00312                 minimumCostCut = leftCoesCut;
00313                 minimumIntersected = 0;
00314                 minimumLeft = 0;
00315         }
00316         <span class="keywordflow">else</span>
00317         {
00318                 minimumCostFound = rightCoesCutCost;
00319                 minimumCostPosition = boundsArray + (nObjects &lt;&lt; 1);
00320                 minimumCostCut = rightCoesCut;
00321                 minimumIntersected = 0;
00322                 minimumLeft = nObjects;
00323         }
00324 
00325         <span class="comment">// creep up to the search interval... count objects</span>
00326         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* trace = boundsArray;
00327         <span class="keywordflow">for</span>(; trace&lt; searchIntervalStart; trace++ )
00328         {
00329                 <span class="keywordflow">if</span>(*trace &amp; 0x80000000)
00330                 {
00331                         intersectedCount--;
00332                         leftCount++;
00333                 }
00334                 <span class="keywordflow">else</span>
00335                         intersectedCount++;
00336         }
00337         <span class="comment">// evaluate the cost function, if better is found keep it</span>
00338         <span class="keywordflow">for</span>(; trace&lt; searchIntervalEnd; trace++ )
00339         {
00340                 <span class="keywordtype">float</span> cut = <a class="code" href="classKDTree.html#c4">getBoundValue</a>(trace, axis);
00341                 <span class="keywordtype">float</span> costIfCutHere;
00342                 <span class="keywordflow">if</span>(*trace &amp; 0x80000000)
00343                 {
00344                         intersectedCount--;
00345                         leftCount++;
00346                         costIfCutHere = 
00347                                 (leftCount+intersectedCount) * ((cut - limiMin) * costSteep + costBase) +
00348                                 (nObjects - leftCount) * ((limiMax - cut) * costSteep + costBase);
00349                         <span class="keywordflow">if</span>(leftCount == 0 || leftCount + intersectedCount == nObjects )
00350                                 costIfCutHere = FLT_MAX;
00351                         <span class="keywordflow">if</span>(costIfCutHere &lt; minimumCostFound ){
00352                                 minimumCostFound = costIfCutHere;
00353                                 minimumCostPosition = trace + 1;
00354                                 minimumIntersected = intersectedCount;
00355                                 minimumLeft = leftCount;
00356                                 minimumCostCut = cut;
00357                         }
00358                 }
00359                 <span class="keywordflow">else</span>
00360                 {
00361                         costIfCutHere = 
00362                                 (leftCount+intersectedCount) * ((cut - limiMin) * costSteep + costBase) +
00363                                 (nObjects - leftCount) * ((limiMax - cut) * costSteep + costBase);
00364                         <span class="keywordflow">if</span>(leftCount == 0 || leftCount + intersectedCount == nObjects)
00365                                 costIfCutHere = FLT_MAX;
00366                         <span class="keywordflow">if</span>(costIfCutHere &lt; minimumCostFound)
00367                         {
00368                                 minimumCostFound = costIfCutHere;
00369                                 minimumCostPosition = trace;
00370                                 minimumIntersected = intersectedCount;
00371                                 minimumLeft = leftCount;
00372                                 minimumCostCut = cut;
00373                         }
00374                         intersectedCount++;
00375                 }
00376 
00377         }
00378 
00379         <span class="comment">// automatic termination, based on the cost estimation</span>
00380         <span class="keywordflow">if</span>(     minimumCostFound * 1.0001 &gt;= nObjects * ((limiMax - limiMin) * costSteep + costBase))
00381         {
00382                 <span class="comment">// no appropriate splitting found, mark this axis as failed</span>
00383                 mask |= (010 &lt;&lt; axis);
00384                 <span class="keywordflow">if</span>(mask != 070 &amp;&amp; (nObjects != 1 || minimumCostFound &lt; 10.0))
00385                 {
00386                         <span class="comment">//if there is still a hopeful axis, do not split here, go on with another direction</span>
00387                         <span class="keywordflow">do</span>{             axis = (axis + 1)%3;
00388                         }<span class="keywordflow">while</span>(mask &amp; (010 &lt;&lt; axis));
00389                         <a class="code" href="classKDTree.html#c1">build</a>(nodeID, boundsArray, nObjects, limits, mask | axis);
00390                         <span class="keywordflow">return</span>;
00391                 }
00392                 <span class="comment">// if all 3 have axes have already failed, stop here, make a leaf</span>
00393                 <span class="comment">// save leaf length and objects list</span>
00394                 <a class="code" href="classIntersectable.html">Intersectable</a>** leafList = <span class="keyword">new</span> <a class="code" href="classIntersectable.html">Intersectable</a>*[nObjects+1];
00395                 Intersectable** leafLoader = leafList;
00396                 *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)leafLoader = nObjects;
00397                 leafLoader++;
00398                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* bubo = boundsArray;bubo &lt; boundsArray + (nObjects &lt;&lt; 1);bubo++)
00399                         <span class="keywordflow">if</span>(!(*bubo &amp; 0x80000000))
00400                         {
00401                                 *leafLoader = *(objects + *bubo);
00402                                 leafLoader++;
00403                         }
00404                 <span class="comment">// make the node contain a pointer to the list</span>
00405                 ((Intersectable ***)<a class="code" href="classKDTree.html#o6">nodeTable</a>)[nodeID] = leafList;
00406                 <span class="keyword">delete</span> boundsArray;
00407                 <span class="comment">//mark the node as a leaf</span>
00408                 ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)<a class="code" href="classKDTree.html#o6">nodeTable</a>)[nodeID | <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>] |= (0x1 &lt;&lt; (nodeID &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>));
00409                 <span class="comment">//add orphaned nodes to free node list</span>
00410                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lFree;
00411                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rFree;
00412                 <span class="keywordflow">if</span>(<a class="code" href="classKDTree.html#c8">getFreeNodes</a>(nodeID, lFree, rFree))
00413                 {
00414                         <a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a2">insert</a>(lFree);
00415                         <a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a2">insert</a>(rFree);
00416                 }
00417                 <span class="keywordflow">return</span>;
00418         }
00419         <span class="comment">// grant another chance to previously failed directions:</span>
00420         mask = 00;
00421         <span class="comment">// insert a back-pointer if necessary</span>
00422         nodeID = <a class="code" href="classKDTree.html#c10">makePointer</a>(nodeID);
00423         <span class="comment">// store the splitting plane value in the node</span>
00424         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bitfield = *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)(&amp;minimumCostCut) &amp; 0xfffffffc | axis;
00425         <a class="code" href="classKDTree.html#o6">nodeTable</a>[nodeID] =  *(<span class="keywordtype">float</span>*)(&amp;bitfield);
00426         <span class="comment">// mark node as a non-leaf node</span>
00427         *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)&amp;<a class="code" href="classKDTree.html#o6">nodeTable</a>[nodeID | <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>] &amp;= ~(0x1 &lt;&lt; (nodeID &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>));
00428 
00429         <a class="code" href="classKDTree.html#o12">currentDepth</a>++; <span class="keywordflow">if</span>(<a class="code" href="classKDTree.html#o12">currentDepth</a> &gt; <a class="code" href="classKDTree.html#o11">depth</a>) <a class="code" href="classKDTree.html#o11">depth</a> = <a class="code" href="classKDTree.html#o12">currentDepth</a>;
00430 
00431         <span class="comment">// allocate child nodes, pass the objects on to them</span>
00432         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> leftChildMade;
00433         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rightChildMade;
00434 
00435         <span class="comment">// handle the two branches, the one with less objects first</span>
00436         <span class="keywordtype">bool</span> firstBranch = <span class="keyword">false</span>;
00437         <span class="keywordtype">bool</span> rightBranchHasMoreObjects = (bool)((minimumLeft &lt;&lt; 1) + minimumIntersected &lt; nObjects);
00438         <a class="code" href="classKDTree.html#c7">followChildren</a>(nodeID, leftChildMade, rightChildMade);
00439         <span class="keywordflow">do</span>
00440         {
00441                 firstBranch = !firstBranch;
00442                 <span class="keywordflow">if</span>(firstBranch &amp;&amp; rightBranchHasMoreObjects
00443                         || !firstBranch &amp;&amp; !rightBranchHasMoreObjects)
00444                 {
00445                         <span class="comment">// left branch</span>
00446                         <span class="keywordflow">if</span>(minimumLeft + minimumIntersected)
00447                         {
00448                                 <span class="comment">// branch has objects</span>
00449                                 <span class="comment">// create new object extrema array</span>
00450                                 <a class="code" href="classBoundingBox.html">BoundingBox</a> diver = limits;
00451                                 limiMax = minimumCostCut;
00452                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * leftChildBounds = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[(minimumLeft + minimumIntersected) &lt;&lt; 1];
00453                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* copycatLeft = leftChildBounds;
00454                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* snoop = boundsArray;
00455                                 <span class="keywordflow">for</span>(; snoop &lt; minimumCostPosition; snoop++)
00456                                 {
00457                                         <span class="comment">// for every mimimum left of cutting plane</span>
00458                                         <span class="keywordflow">if</span>(!(*snoop &amp; 0x80000000))
00459                                         {
00460                                                 <span class="comment">// add one for the mimimum</span>
00461                                                 *copycatLeft = *snoop;
00462                                                 copycatLeft++;
00463                                                 <span class="comment">// add one for the maximum</span>
00464                                                 *copycatLeft = *snoop | 0x80000000;
00465                                                 copycatLeft++;
00466                                         }
00467                                 }
00468                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> turnedAxis = axis;
00469                                 <span class="keywordflow">do</span>{             turnedAxis = (turnedAxis + 1)%3;
00470                                 }<span class="keywordflow">while</span>(mask &amp; (010 &lt;&lt; turnedAxis));
00471                                 <a class="code" href="classKDTree.html#c1">build</a>(leftChildMade, leftChildBounds, minimumLeft + minimumIntersected, limits, mask | turnedAxis);
00472                                 limits = diver;
00473                         }
00474                         <span class="keywordflow">else</span>
00475                         {
00476                                 <span class="comment">// make empty leaf</span>
00477                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> empty = leftChildMade;
00478                                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *&amp;)<a class="code" href="classKDTree.html#o6">nodeTable</a>[empty] = 0x0;
00479                                 *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)&amp;<a class="code" href="classKDTree.html#o6">nodeTable</a>[empty | <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>] |= 0x1 &lt;&lt; (empty &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>);
00480                                 <span class="comment">// add orphaned nodes to free list</span>
00481                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eleLeft;
00482                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eleRight;
00483                                 <span class="keywordflow">if</span>(<a class="code" href="classKDTree.html#c8">getFreeNodes</a>(empty, eleLeft, eleRight))
00484                                 {
00485                                         <a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a2">insert</a>(eleLeft);
00486                                         <a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a2">insert</a>(eleRight);
00487                                 }
00488                         }
00489                 }
00490                 <span class="keywordflow">else</span>
00491                 {
00492                         <span class="keywordflow">if</span>(nObjects - minimumLeft)
00493                         {
00494                                 <a class="code" href="classBoundingBox.html">BoundingBox</a> diver = limits;
00495                                 limiMin = minimumCostCut;
00496 
00497                                 <span class="comment">// create new bounds array</span>
00498                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * rightChildBounds;
00499                                 rightChildBounds = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[(nObjects - minimumLeft) &lt;&lt; 1 ];
00500 
00501                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* copycatRight = rightChildBounds;
00502                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* snoop = minimumCostPosition;
00503                                 <span class="keywordflow">for</span>(; snoop &lt; boundsArray + (nObjects &lt;&lt; 1); snoop++)
00504                                 {
00505                                         <span class="comment">// for every maximum right of cutting plane</span>
00506                                         <span class="keywordflow">if</span>(*snoop &amp; 0x80000000)
00507                                         {
00508                                                 *copycatRight = *snoop &amp; 0x7fffffff;
00509                                                 copycatRight++;
00510                                                 *copycatRight = *snoop;
00511                                                 copycatRight++;
00512                                         }
00513                                 }
00514 
00515                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> turnedAxis = axis;
00516                                 <span class="keywordflow">do</span>{     turnedAxis = (turnedAxis + 1)%3;
00517                                 }<span class="keywordflow">while</span>(mask &amp; (010 &lt;&lt; turnedAxis));
00518                                 <a class="code" href="classKDTree.html#c1">build</a>(rightChildMade, rightChildBounds, nObjects - minimumLeft, limits, mask | turnedAxis);
00519                                 limits = diver;
00520                         }
00521                         <span class="keywordflow">else</span>
00522                         {
00523                                 <span class="comment">// empty leaf</span>
00524                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> empty = rightChildMade;
00525                                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *&amp;)<a class="code" href="classKDTree.html#o6">nodeTable</a>[empty] = 0x0;
00526                                 *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)&amp;<a class="code" href="classKDTree.html#o6">nodeTable</a>[empty | <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>] |= 0x1 &lt;&lt; (empty &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>);
00527                                 <span class="comment">// orphaned nodes</span>
00528                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eleLeft;
00529                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eleRight;
00530                                 <span class="keywordflow">if</span>(<a class="code" href="classKDTree.html#c8">getFreeNodes</a>(empty, eleLeft, eleRight))
00531                                 {
00532                                         <a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a2">insert</a>(eleLeft);
00533                                         <a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a2">insert</a>(eleRight);
00534                                 }
00535                         }
00536                 }
00537         }<span class="keywordflow">while</span>(firstBranch);
00538         currentDepth--;
00539         <span class="keyword">delete</span> boundsArray;
00540 }
00541 
<a name="l00542"></a><a class="code" href="classKDTree.html#c2">00542</a> <span class="keywordtype">void</span> <a class="code" href="classKDTree.html#c2">KDTree::quickSort</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *lo0, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* hi0, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> axis)
00543 {
00544         <span class="keywordflow">if</span> ( hi0 &gt; lo0)
00545         {
00546                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* lo = lo0;
00547                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* hi = hi0;
00548 
00549          <span class="comment">// establish partition element as the midpoint of the array.</span>
00550                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* midPos =  
00551                         lo0 + ( ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)hi0 - (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)lo0) / <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) / 2);
00552                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> midIndex = *midPos;
00553 
00554          <span class="comment">// loop through the array until indices cross</span>
00555                 <span class="keywordflow">while</span>( lo &lt;= hi )
00556                 {
00557             <span class="comment">// find the first element that is greater than or equal to </span>
00558             <span class="comment">// the partition element starting from the left Index.</span>
00559                         <span class="comment">// getBoundValue(lo, axis) &lt; mid ) &amp;&amp; *lo != midIndex)</span>
00560                         <span class="keywordflow">while</span>( ( lo &lt; hi0 ) &amp;&amp; ( <a class="code" href="classKDTree.html#c3">compare</a>(*lo, midIndex, axis)))
00561                                 ++lo;
00562 
00563             <span class="comment">// find an element that is smaller than or equal to </span>
00564             <span class="comment">// the partition element starting from the right Index.</span>
00565                         <span class="comment">//( getBoundValue(hi, axis) &gt; mid ) &amp;&amp; *hi != midIndex)</span>
00566             <span class="keywordflow">while</span>( ( hi &gt; lo0 ) &amp;&amp; ( <a class="code" href="classKDTree.html#c3">compare</a>(midIndex, *hi, axis)))
00567                --hi;            
00568                         <span class="comment">// if the indices have not crossed, swap</span>
00569             <span class="keywordflow">if</span>( lo &lt;= hi )
00570                         {
00571                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temp = *lo;
00572                                 *lo = *hi;
00573                                 *hi = temp;
00574                                 ++lo;
00575                                 --hi;
00576                         }         
00577                 }
00578         <span class="comment">// If the right index has not reached the left side of array</span>
00579         <span class="comment">// must now sort the left partition.</span>
00580         <span class="keywordflow">if</span>( lo0 &lt; hi )
00581             <a class="code" href="classKDTree.html#c2">quickSort</a>( lo0, hi, axis);
00582                 <span class="comment">// If the left index has not reached the right side of array</span>
00583         <span class="comment">// must now sort the right partition.</span>
00584                 <span class="keywordflow">if</span>( lo &lt; hi0 )
00585             <a class="code" href="classKDTree.html#c2">quickSort</a>( lo, hi0, axis);
00586         }
00587 }
00588 
<a name="l00589"></a><a class="code" href="classKDTree.html#a0">00589</a> <a class="code" href="classKDTree.html#a0">KDTree::KDTree</a> (<a class="code" href="classIntersectable.html">Intersectable</a>** iObjects, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nObjects){
00590         <span class="comment">// take parameters</span>
00591         this-&gt;nObjects          = nObjects;
00592         <a class="code" href="classKDTree.html#o8">objects</a> = iObjects;
00593 
00594         <span class="comment">// determine bounding box</span>
00595         <a class="code" href="classKDTree.html#c9">createBoundingBox</a> (iObjects, nObjects);
00596 
00597         <span class="comment">// determine error because of 21 bits mantissa representaion</span>
00598         <span class="keywordtype">float</span> largest = 0.0f;
00599         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;3; i++)
00600                 <span class="keywordflow">if</span>( <a class="code" href="classKDTree.html#o4">boundingBox</a>.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>[i] &gt; largest)
00601                         largest = <a class="code" href="classKDTree.html#o4">boundingBox</a>.<a class="code" href="classBoundingBox.html#m1">maxPoint</a>[i];
00602         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> o=0; o&lt;3; o++)
00603                 <span class="keywordflow">if</span>( - <a class="code" href="classKDTree.html#o4">boundingBox</a>.<a class="code" href="classBoundingBox.html#m0">minPoint</a>[o] &gt; largest)
00604                         largest = - <a class="code" href="classKDTree.html#o4">boundingBox</a>.<a class="code" href="classBoundingBox.html#m0">minPoint</a>[o];
00605         <a class="code" href="classKDTree.html#o13">epsilon</a> = largest / 524288.0f; <span class="comment">// e = X * 2^(-19);</span>
00606 
00607         <span class="comment">// set up memory structure constants</span>
00608         <a class="code" href="classKDTree.html#o3">nCacheLineBytes</a> = <a class="code" href="KDTree_8hpp.html#a0">KDTREE_CACHE_LINE_BYTES</a>;
00609         <span class="comment">// a cache line has 2^n - 1 nodes, plus 4 bytes (1 node) for leaf bits</span>
00610         <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a> = <a class="code" href="classKDTree.html#o3">nCacheLineBytes</a> / <span class="keyword">sizeof</span>(float) - 1;
00611 
00612         <span class="comment">// size of cache line memory pool</span>
00613         <a class="code" href="classKDTree.html#o1">maxNCacheLines</a> = nObjects * 16 / <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a> + 1;
00614         <span class="comment">// cache lines already allocated</span>
00615         <a class="code" href="classKDTree.html#o0">nCacheLines</a> = 1;
00616 
00617         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxPossibleFree = <a class="code" href="classKDTree.html#o1">maxNCacheLines</a> * <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a> / 2;
00618         <span class="comment">// allocate free nodes heap</span>
00619         <a class="code" href="classKDTree.html#o9">freeNodes</a> = <span class="keyword">new</span> <a class="code" href="classHeap.html">Heap&lt;unsigned int&gt;</a>(maxPossibleFree);
00620 
00621         <span class="comment">// allocate cache line memory pool (large size, will be shrinked after the build)</span>
00622         <span class="comment">// nodes in cache line pool + offset correction</span>
00623         <a class="code" href="classKDTree.html#o5">poolNodeTable</a> = (<span class="keywordtype">float</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) *
00624                 ( maxNCacheLines * (nCacheLineNodes + 1) + nCacheLineNodes + 1 ));
00625         <a class="code" href="classKDTree.html#o6">nodeTable</a> = (<span class="keywordtype">float</span>*)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<a class="code" href="classKDTree.html#o5">poolNodeTable</a> / <a class="code" href="classKDTree.html#o3">nCacheLineBytes</a> + 1) * <a class="code" href="classKDTree.html#o3">nCacheLineBytes</a>);
00626 
00627         <span class="comment">// collect the initial object extremes to pass on to the build algorithm</span>
00628         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* objectBoundaries = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nObjects &lt;&lt; 1];
00629         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fill=0;fill&lt;nObjects;fill++){
00630                 objectBoundaries[fill &lt;&lt; 1] = fill &amp; 0x7fffffff;
00631                 objectBoundaries[(fill &lt;&lt; 1) + 1] = fill | 0x80000000;
00632         }
00633 
00634         <span class="comment">// GO! GO! GO!</span>
00635         <a class="code" href="classKDTree.html#o11">depth</a> = <a class="code" href="classKDTree.html#o12">currentDepth</a> = 1;
00636         <a class="code" href="classKDTree.html#c1">build</a>(0, objectBoundaries, nObjects, boundingBox, 0);
00637         <a class="code" href="classKDTree.html#o10">traverseStack</a> = <span class="keyword">new</span> <a class="code" href="structKDTree_1_1TraverseStack.html">TraverseStack</a>[<a class="code" href="classKDTree.html#o11">depth</a>];
00638 
00639         <span class="comment">// get rid of garbage</span>
00640         <span class="comment">// decrease cache line memory pool to fit actual memory need</span>
00641         realloc(poolNodeTable, (nCacheLines + 1) * nCacheLineBytes);
00642         <span class="keyword">delete</span> <a class="code" href="classKDTree.html#o9">freeNodes</a>;
00643 }
00644 
<a name="l00645"></a><a class="code" href="classKDTree.html#c5">00645</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* <a class="code" href="classKDTree.html#c5">KDTree::findBound</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *extremeArrayStart, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nBounds, <span class="keywordtype">float</span> loc, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> axis)
00646 {
00647         <span class="keywordflow">while</span>(nBounds &gt; 1)
00648         {
00649                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wBounds = nBounds &gt;&gt; 1;
00650                 <span class="keywordflow">if</span>(<a class="code" href="classKDTree.html#c4">getBoundValue</a>(extremeArrayStart+wBounds, axis) &lt; loc)
00651                 {
00652                         extremeArrayStart += wBounds;
00653                         nBounds -= wBounds;
00654                 }
00655                 <span class="keywordflow">else</span>
00656                         nBounds = wBounds;
00657         }
00658         <span class="keywordflow">return</span> extremeArrayStart;
00659 
00660 }
00661 <span class="comment"></span>
00662 <span class="comment">/*!this is more complicated then one would predict. rules are:</span>
00663 <span class="comment">- if values are significantly different, no problem</span>
00664 <span class="comment">- the minimum of a patch is smaller than its maximum</span>
00665 <span class="comment">- if a maximum and a minimum are near, the other extrema of the patches decide</span>
00666 <span class="comment">- if all four extrema are near, the 2 ends of a patch have to be simultaneusly</span>
00667 <span class="comment">smaller or bigger than the other two ends</span>
00668 <span class="comment">*/</span>
<a name="l00669"></a><a class="code" href="classKDTree.html#c3">00669</a> <span class="keywordtype">bool</span> <a class="code" href="classKDTree.html#c3">KDTree::compare</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> aIndex, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bIndex, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> axis)
00670 {
00671 
00672         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> caIndex = aIndex &amp; 0x7fffffff;
00673         <span class="keywordtype">float</span> aBegin = <a class="code" href="classKDTree.html#o8">objects</a>[caIndex]-&gt;<a class="code" href="classIntersectable.html#m1">bbox</a>.<a class="code" href="classBoundingBox.html#m0">minPoint</a>[axis];
00674         <span class="keywordtype">float</span> aEnd = objects[caIndex]-&gt;bbox.maxPoint[axis];
00675         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cbIndex = bIndex &amp; 0x7fffffff;
00676         <span class="keywordtype">float</span> bBegin = objects[cbIndex]-&gt;bbox.minPoint[axis];
00677         <span class="keywordtype">float</span> bEnd = objects[cbIndex]-&gt;bbox.maxPoint[axis];
00678         
00679         <span class="keywordflow">if</span>(aIndex &amp; 0x80000000)
00680                 <span class="keywordflow">if</span>(bIndex &amp; 0x80000000)
00681                 {
00682                         <span class="keywordflow">if</span>(caIndex == cbIndex)
00683                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00684                         <span class="keywordflow">if</span>(aEnd + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; bEnd)
00685                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00686                         <span class="keywordflow">if</span>(bEnd + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; aEnd)
00687                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00688                         <span class="keywordflow">if</span>(aBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; bBegin)
00689                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00690                         <span class="keywordflow">if</span>(bBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; aBegin)
00691                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00692                         <span class="keywordflow">return</span> caIndex &lt; cbIndex;
00693                 }
00694                 <span class="keywordflow">else</span>
00695                 {
00696                         <span class="keywordflow">if</span>(caIndex == cbIndex)
00697                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00698                         <span class="keywordflow">if</span>(aEnd + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; bBegin)
00699                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00700                         <span class="keywordflow">if</span>(bBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; aEnd)
00701                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00702                         <span class="keywordflow">if</span>(aBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; bEnd)
00703                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00704                         <span class="keywordflow">return</span> caIndex &lt; cbIndex;
00705 
00706                 }
00707         <span class="keywordflow">else</span>
00708                 <span class="keywordflow">if</span>(bIndex &amp; 0x80000000)
00709                 {
00710                         <span class="keywordflow">if</span>(caIndex == cbIndex)
00711                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00712                         <span class="keywordflow">if</span>(bEnd + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; aBegin)
00713                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00714                         <span class="keywordflow">if</span>(aBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; bEnd)
00715                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00716                         <span class="keywordflow">if</span>(bBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; aEnd)
00717                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00718                         <span class="keywordflow">return</span> caIndex + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; cbIndex;
00719                 }
00720                 <span class="keywordflow">else</span>
00721                 {
00722                         <span class="keywordflow">if</span>(caIndex == cbIndex)
00723                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00724                         <span class="keywordflow">if</span>(aBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; bBegin)
00725                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00726                         <span class="keywordflow">if</span>(bBegin + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; aBegin)
00727                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00728                         <span class="keywordflow">if</span>(aEnd + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; bEnd)
00729                                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00730                         <span class="keywordflow">if</span>(bEnd + <a class="code" href="classKDTree.html#o13">epsilon</a> &lt; aEnd)
00731                                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00732                         <span class="keywordflow">return</span> caIndex &lt; cbIndex;
00733 
00734                 }
00735 }
00736 
<a name="l00737"></a><a class="code" href="classKDTree.html#c10">00737</a> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classKDTree.html#c10">KDTree::makePointer</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> originalNode)
00738 {
00739         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subPos = originalNode &amp; <a class="code" href="classKDTree.html#o2">nCacheLineNodes</a>;           <span class="comment">// position within cache line</span>
00740         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> supPos = originalNode &amp; ~nCacheLineNodes;          <span class="comment">// index of cache line</span>
00741         subPos = (subPos &lt;&lt; 1) + 1;                                                                     <span class="comment">// child position</span>
00742         <span class="keywordflow">if</span>(subPos &lt; nCacheLineNodes)                                                            <span class="comment">// within cache line</span>
00743         {
00744                 <span class="keywordflow">return</span> originalNode;
00745         }
00746         <span class="keywordflow">else</span>                                                                                                            <span class="comment">// find free node</span>
00747         {
00748                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> emptyNode;
00749                 <span class="keywordflow">if</span>(!<a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a4">isEmpty</a>())
00750                 {
00751                         emptyNode = <a class="code" href="classKDTree.html#o9">freeNodes</a>-&gt;<a class="code" href="classHeap.html#a3">removeMin</a>();
00752                 }
00753                 <span class="keywordflow">else</span>
00754                 {
00755                         <span class="comment">//allocate a new cache line</span>
00756                         emptyNode = <a class="code" href="classKDTree.html#o0">nCacheLines</a> * (nCacheLineNodes + 1);        <span class="comment">// root of new cache line</span>
00757                         <a class="code" href="classKDTree.html#o0">nCacheLines</a>++;
00758                         <span class="keywordflow">if</span>(<a class="code" href="classKDTree.html#o0">nCacheLines</a> &gt; <a class="code" href="classKDTree.html#o1">maxNCacheLines</a>)
00759                         {
00760                                 <a class="code" href="classKDTree.html#o1">maxNCacheLines</a> = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(<a class="code" href="classKDTree.html#o1">maxNCacheLines</a> * 1.1f);
00761                                 <span class="keywordtype">float</span> * largerPoolNodeTable = (<span class="keywordtype">float</span>*)malloc(
00762                                         <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * ( maxNCacheLines * (nCacheLineNodes + 1) + nCacheLineNodes + 1 ));
00763                                 <span class="keywordtype">float</span>* largerNodeTable = (<span class="keywordtype">float</span>*)(((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)largerPoolNodeTable / <a class="code" href="classKDTree.html#o3">nCacheLineBytes</a> + 1) * <a class="code" href="classKDTree.html#o3">nCacheLineBytes</a>);
00764                                 memcpy(largerNodeTable, nodeTable, nCacheLines * nCacheLineBytes);
00765                                 <a class="code" href="classKDTree.html#o6">nodeTable</a> = largerNodeTable;
00766                                 free(poolNodeTable);
00767                                 <a class="code" href="classKDTree.html#o5">poolNodeTable</a> = largerPoolNodeTable;
00768                         }
00769                 }
00770                 <span class="comment">// mark as non-leaf (being last-row and non-leaf means pointer node)</span>
00771                 *(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)&amp;<a class="code" href="classKDTree.html#o6">nodeTable</a>[originalNode | nCacheLineNodes] &amp;= ~(0x1 &lt;&lt; (originalNode &amp; nCacheLineNodes));
00772                 <span class="comment">// insert index of empty node</span>
00773                 ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)<a class="code" href="classKDTree.html#o6">nodeTable</a>)[originalNode] = emptyNode;
00774                 <span class="keywordflow">return</span> emptyNode;
00775         }
00776 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Feb 18 18:30:34 2003 for Stochastic Iteration for Non-diffuse Global Illumination by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
