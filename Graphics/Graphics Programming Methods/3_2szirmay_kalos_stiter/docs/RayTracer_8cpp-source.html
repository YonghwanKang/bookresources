<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RayTracer.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3-rc2 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>RayTracer.cpp</h1><a href="RayTracer_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// Graphics Programming Methods</span>
00002 <span class="comment">// An Effective kd-tree Implementation</span>
00003 <span class="comment">// László Szécsi</span>
00004 <span class="comment">// 2003.</span>
00005 
00006 <span class="comment">// a minimal ray tracing framework for demonstration</span>
00007 
00008 <span class="preprocessor">#include "raytracer.h"</span>
00009 <span class="preprocessor">#include "stdio.h"</span>
00010 
00011 <span class="preprocessor">#ifdef NEVER</span>
00012 <span class="preprocessor"></span><span class="comment">// set up a simple scene for demonstration</span>
00013 <span class="keywordtype">void</span> RayTracer::createScene()
00014 {
00015         eyePosition = <a class="code" href="classVector.html">Vector</a>(-1.0f, -1.0f, 1.0f);
00016         lookPosition = Vector(0.5f, 0.5f, 0.0f);
00017 
00018         nVirtualWorldLights = 2;
00019         virtualWorldLights = <span class="keyword">new</span> <a class="code" href="classLight.html">Light</a>[2];
00020         nVirtualWorldVertices = 81;
00021         virtualWorldVertices = <span class="keyword">new</span> Vector[nVirtualWorldVertices];
00022         nVirtualWorldObjects = 128 + 1;
00023         virtualWorldObjects = <span class="keyword">new</span> <a class="code" href="classIntersectable.html">Intersectable</a>*[nVirtualWorldObjects];
00024 
00025         virtualWorldLights[0] = Light(Vector(0.0f, 1.0f, 1.0f), Vector(0.9f, 0.6f, 0.3f));
00026         virtualWorldLights[1] = Light(Vector(1.0f, 0.0f, 1.0f), Vector(0.3f, 0.6f, 0.9f));
00027 
00028         <span class="keywordtype">int</span> iVertex = 0;
00029         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;9; x++)
00030                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0;y&lt;9;y++)
00031                         virtualWorldVertices[iVertex++] = Vector(x / 8.0f, y / 8.0f, 0.0f);
00032 
00033         <span class="keywordtype">int</span> iObject = 0;
00034         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> a=0; a&lt;8; a++)
00035                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> b=0; b&lt;8; b++)
00036                 {
00037                         virtualWorldObjects[iObject++] = <span class="keyword">new</span> <a class="code" href="classTriangle.html">Triangle</a>(
00038                                                 virtualWorldVertices + a + 1 + b * 9,
00039                                                 virtualWorldVertices + a + b * 9,
00040                                                 virtualWorldVertices + a + (b + 1) * 9,
00041                                                 ((a+b)%2)?&amp;Material::DIFFUSEWHITE:&amp;Material::SHINYBLACK);
00042                         virtualWorldObjects[iObject++] = <span class="keyword">new</span> Triangle(
00043                                                 virtualWorldVertices + a + 1 + b * 9,
00044                                                 virtualWorldVertices + a + (b + 1) * 9,
00045                                                 virtualWorldVertices + a + 10 + b * 9,
00046                                                 ((a+b)%2)?&amp;Material::DIFFUSEWHITE:&amp;Material::SHINYBLACK);
00047                 }
00048 
00049         virtualWorldObjects[iObject++] = <span class="keyword">new</span> Sphere(Vector(0.5f, 0.5f, 0.31f), 0.2f, &amp;Material::STEEL);
00050 
00051         kdtree = <span class="keyword">new</span> <a class="code" href="classKDTree.html">KDTree</a>(virtualWorldObjects, nVirtualWorldObjects);
00052 
00053 }
00054 
00055 <span class="comment">// recursive ray-tracing</span>
00056 <span class="keywordtype">void</span> RayTracer::render()
00057 {
00058         <span class="keywordtype">float</span> pixelEdgeLength = 2.0f * tanf(3.14159265358979323846f / 8.0f) / imageSize;
00059         Vector upwards(0.0f, 0.0f, 1.0f);
00060         Vector eyeCoordsZ = lookPosition - eyePosition;
00061         eyeCoordsZ.<a class="code" href="classVector.html#a20">Normalize</a>();
00062         Vector eyeCoordsX = eyeCoordsZ &amp;&amp; upwards;
00063         Vector eyeCoordsY = eyeCoordsZ &amp;&amp; eyeCoordsX;
00064 
00065         <span class="keywordtype">int</span> rayId = 1;
00066         <a class="code" href="classRay.html">Ray</a> ray;
00067         <a class="code" href="classHitRec.html">HitRec</a> hitRec;
00068         <span class="keywordtype">int</span> halfImageSize = imageSize / 2;
00069         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=-halfImageSize; j &lt; halfImageSize; j++)
00070                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=-halfImageSize; k &lt; halfImageSize; k++)
00071                 {
00072                         Vector radianceInPixel((<span class="keywordtype">float</span>)(halfImageSize + j) / (<span class="keywordtype">float</span>)imageSize, (<span class="keywordtype">float</span>)(halfImageSize + k) /(<span class="keywordtype">float</span>)imageSize, 0.5f);
00073                         Vector idealBrdf(1.0f, 1.0f, 0.1f);
00074                         ray.<a class="code" href="classRay.html#m0">origin</a> = eyePosition;
00075                         ray.<a class="code" href="classRay.html#m1">dir</a> =   eyeCoordsX * (pixelEdgeLength * k) +
00076                                                 eyeCoordsY * (pixelEdgeLength * j) +
00077                                                 eyeCoordsZ;
00078                         ray.<a class="code" href="classRay.html#m1">dir</a>.<a class="code" href="classVector.html#a20">Normalize</a>();
00079                         ray.<a class="code" href="classRay.html#m2">id</a> = rayId++;
00080 
00081                         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> depth=0; depth &lt; maxSteps; depth++)
00082                         {
00083                                 kdtree-&gt;traverse(ray, hitRec, 0.00001f, 100000000000.0f);
00084                                 <span class="keywordflow">if</span>(!hitRec.<a class="code" href="classHitRec.html#m2">object</a>)
00085                                         <span class="keywordflow">break</span>;
00086                                 Vector normal = hitRec.<a class="code" href="classHitRec.html#m2">object</a>-&gt;<a class="code" href="classIntersectable.html#a3">getShadingNormal</a>(hitRec.<a class="code" href="classHitRec.html#m0">point</a>);
00087                                 radianceInPixel = Vector(0.0f, 0.0f, 0.0f);
00088                                 <a class="code" href="classRay.html">Ray</a> shadowRay;
00089                                 shadowRay.<a class="code" href="classRay.html#m0">origin</a> = hitRec.<a class="code" href="classHitRec.html#m0">point</a>;
00090                                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> iLight=0; iLight &lt; nVirtualWorldLights; iLight++)
00091                                 {
00092                                         shadowRay.<a class="code" href="classRay.html#m2">id</a> = rayId++;
00093                                         shadowRay.<a class="code" href="classRay.html#m1">dir</a> = virtualWorldLights[iLight].position - shadowRay.<a class="code" href="classRay.html#m0">origin</a>;
00094                                         <span class="keywordtype">float</span> distance = shadowRay.<a class="code" href="classRay.html#m1">dir</a>.<a class="code" href="classVector.html#a20">Normalize</a>();
00095                                         <a class="code" href="classHitRec.html">HitRec</a> shadowHit;
00096                                         kdtree-&gt;traverse(shadowRay, shadowHit, 0.00001f, distance);
00097                                         <span class="keywordflow">if</span>(!shadowHit.<a class="code" href="classHitRec.html#m3">isIntersect</a>)
00098                                         {
00099                                                 Vector lightBrdfValue;
00100                                                 hitRec.<a class="code" href="classHitRec.html#m2">object</a>-&gt;material-&gt;ScatteringProbability(ray.<a class="code" href="classRay.html#m1">dir</a>, shadowRay.<a class="code" href="classRay.html#m1">dir</a>, normal, lightBrdfValue);
00101                                                 radianceInPixel += (idealBrdf % lightBrdfValue % virtualWorldLights[iLight].radiance) * (1.0f / (distance * distance));
00102                                         }
00103                                 }
00104                                 <span class="keywordflow">if</span>((depth &lt; maxSteps - 1) &amp;&amp; hitRec.<a class="code" href="classHitRec.html#m2">object</a>-&gt;material-&gt;isMirror())
00105                                 {
00106                                         ray.<a class="code" href="classRay.html#m0">origin</a> = hitRec.<a class="code" href="classHitRec.html#m0">point</a>;
00107                                         Vector reflectionDir;
00108                                         reflectionDir.<a class="code" href="classVector.html#a29">SetIdealReflectedDirection</a>(ray.<a class="code" href="classRay.html#m1">dir</a>, normal);
00109                                         Vector idealBrdfValue;
00110                                         hitRec.<a class="code" href="classHitRec.html#m2">object</a>-&gt;material-&gt;EvalReflectivity(idealBrdfValue);
00111                                         idealBrdf %= idealBrdfValue;
00112                                         ray.<a class="code" href="classRay.html#m1">dir</a> = reflectionDir;
00113                                 }
00114                         }
00115                         image[(halfImageSize + j) * imageSize + (halfImageSize + k)] = radianceInPixel;
00116                 }
00117 
00118 }
00119 
00120 <span class="comment">// save rendered image as a TGA file</span>
00121 <span class="keywordtype">void</span> RayTracer::saveImage(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)
00122 {
00123         FILE* file = fopen(filename, <span class="stringliteral">"w+b"</span>);
00124 
00125         fputc(0,file);
00126         fputc(0,file);
00127         fputc(2,file);
00128         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=3;i&lt;12;i++) 
00129                 fputc(0,file);
00130         fputc(imageSize&amp;0xff,file);
00131         fputc(imageSize/256,file);
00132         fputc(imageSize&amp;0xff,file);
00133         fputc(imageSize/256,file);
00134         fputc(24,file);
00135         fputc(32,file);
00136 
00137         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = 0; y &lt; nPixels; y++ )
00138         {
00139                 <span class="keywordtype">float</span> tone = 200.0;
00140                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> red = image[y].r * tone;
00141                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> green = image[y].g * tone;
00142                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blue = image[y].b * tone;
00143 
00144                 <span class="keywordflow">if</span> (blue &gt; 255) blue = 255;
00145                 <span class="keywordflow">if</span> (green &gt; 255) green = 255;
00146                 <span class="keywordflow">if</span> (red &gt; 255) red = 255;
00147 
00148                 fputc(blue,file);
00149                 fputc(green,file);
00150                 fputc(red,file);
00151         }
00152         fclose(file);
00153 }
00154 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Feb 18 18:30:34 2003 for Stochastic Iteration for Non-diffuse Global Illumination by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.3-rc2 </small></address>
</body>
</html>
