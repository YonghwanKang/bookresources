<html>
<head>
</head>
<body bgcolor="#CCCCCC">
<h2 align="center">Source Code - CParser.java</h2>
<p>/* Generated By:JavaCC: Do not edit this line. CParser.java */<br>
import java.util.*;<br>
import java.lang.Object;<br>
abstract class Expression {}</p>
<p> class Constants<br>
  {<br>
  public static final int INTEGER=1;<br>
  public static final int FLOAT=2;<br>
  public static final int DOUBLE=3;<br>
  public static final int SHORTINT=4;<br>
  public static final int UNSIGNEDCHAR=5;<br>
  public static final int LONG=6;<br>
  public static final int LONGINTEGER=7;<br>
  public static final int SIGNEDINT=8;<br>
  public static final int UNSIGNEDINTEGER=9;<br>
  public static final int USERTYPE=10;<br>
  public static final int ARRAYTYPE=11;<br>
  public static final int AUTO=12;<br>
  public static final int STATIC=13;<br>
  public static final int REGISTER=14;<br>
  public static final int EXTERN=15;<br>
  public static final int TYPEDEF=16;<br>
  public static final int CONSTANT=17;<br>
  public static final int RESTRICT=18;<br>
  public static final int VOLATILE=19;<br>
  public static final int SIGNED=20;<br>
  public static final int BASIC=21;<br>
  public static final int ARRAY=22;<br>
  public static final int VOID=23;<br>
  public static final int SHORT=24;<br>
  public static final int CHAR=25;<br>
  }</p>
<p> class _integerLiteral extends Expression<br>
  {<br>
  int value;<br>
  _integerLiteral(int v) {value = v;}<br>
  public String toString() {return value + &quot;&quot;;}<br>
  }</p>
<p> class _floatingPointLiteral extends Expression<br>
  {<br>
  double value;<br>
  _floatingPointLiteral (double v) {value = v;}<br>
  public String toString() {return value + &quot;&quot;;}<br>
  }<br>
  class _stringLiteral extends Expression<br>
  {<br>
  String value;<br>
  _stringLiteral (String v) {value = v;}<br>
  public String toString() {return value + &quot;&quot;;}<br>
  }<br>
  class _identifier extends Expression<br>
  {<br>
  String value;<br>
  _identifier(String v) {value = v;}<br>
  public String toString() {return value + &quot;&quot;;}<br>
  }</p>
<p> class IC3A extends Expression<br>
  {<br>
  String opcode,lvalue,label;<br>
  static int tcnt;<br>
  Expression operand1, operand2;<br>
  IC3A(String lbl,String opc, Expression opr1, Expression opr2, String lval)<br>
  {<br>
  label=lbl;<br>
  opcode = opc;<br>
  operand1 = opr1;<br>
  operand2 = opr2;<br>
  lvalue = lval;<br>
  CParser.labelpending = &quot; &quot;;<br>
  }<br>
  }<br>
  class Type<br>
  {<br>
  int type;                 //ID or Const, Basic, Array, Pointer, Referernce, File, Function<br>
  int subtype;              //char, integer, long, float,double<br>
  String value;<br>
  int dimensionCnt;<br>
  Type ()<br>
  {<br>
  type=Constants.INTEGER;<br>
  value=&quot; &quot;;<br>
  dimensionCnt=0;<br>
  }<br>
  }<br>
  class Symbol<br>
  {<br>
  String name;              //ID lexeme<br>
  Type type;<br>
  int storage;              //Storage type: auto, register, static, typedef<br>
  int qualifier;            //Qualifier: Constant, Volatile<br>
  int sign;                 //unsigned, signed<br>
  int width;                //width of the data if applicable<br>
  String widthType;                         //width type (short or long - applicable to integer<br>
  int iVal;<br>
  float fVal;<br>
  String sVal;<br>
  Symbol structLink;                      //to hold the fields of the structure<br>
  int relAddr;                    //Relative address of each symbol</p>
<p> Symbol()<br>
  {<br>
  type = new Type();<br>
  type.type = Constants.BASIC;<br>
  type.subtype = Constants.INTEGER;<br>
  storage = Constants.AUTO;<br>
  qualifier = Constants.VOLATILE;<br>
  sign=Constants.SIGNED;<br>
  width=4;<br>
  widthType=&quot; &quot;;<br>
  sVal=&quot; &quot;;<br>
  structLink=null;<br>
  relAddr=0;<br>
  }<br>
  }<br>
  class Literal<br>
  {<br>
  int type;<br>
  int iVal;<br>
  double dVal;<br>
  String sVal;<br>
  Literal()<br>
  {<br>
  type=Constants.INTEGER;<br>
  iVal=0;<br>
  dVal=0.0;<br>
  sVal=&quot; &quot;;<br>
  }<br>
  }</p>
<p> class SymTab<br>
  {<br>
  HashMap hm;<br>
  SymTab prevTab;<br>
  HashMap structLink;<br>
  SymTab()<br>
  {<br>
  hm=null;<br>
  prevTab=null;<br>
  structLink=null;<br>
  }<br>
  void dispSymbols()<br>
  {<br>
  Set s = hm.entrySet();<br>
  Iterator i = s.iterator();<br>
  System.out.println(&quot;Name\u005ct&quot;+&quot;Type\u005ct&quot;+&quot;Sub Type\u005ct&quot;+&quot;Width\u005cn&quot;);<br>
  while (i.hasNext())<br>
  {<br>
  Map.Entry me = (Map.Entry)i.next();<br>
  System.out.print(me.getKey() + &quot;\u005ct&quot;);<br>
  Symbol symbol=(Symbol)me.getValue();<br>
  System.out.print(symbol.type.type+&quot;\u005ct\u005ct&quot;+symbol.type.subtype+&quot;\u005ct\u005ct&quot;+symbol.width+&quot;\u005cn&quot;);<br>
  }<br>
  }<br>
  }</p>
<p> public class CParser implements CParserConstants {<br>
  static Vector&lt;IC3A&gt; vec;<br>
  static IC3A ic3a;<br>
  static int tcnt;<br>
  static int lcnt;<br>
  static Symbol symbol;<br>
  //static HashMap hm=null,prevTab=null;  //hash map and current active hm;<br>
  static SymTab symTab = null;<br>
  static SymTab prevsymTab = null;<br>
  static SymTab ctSymTab = null;<br>
  static String labelpending = &quot; &quot;;<br>
  static int errcnt=0;<br>
  public static void main(String args[])<br>
  {</p>
<p> CParser cparser;<br>
  vec = new Vector&lt;IC3A&gt;();<br>
  symTab = new SymTab();<br>
  symTab.prevTab=null;<br>
  symTab.structLink = null;<br>
  symTab.hm = new HashMap();<br>
  tcnt = 0;<br>
  if (args.length == 0)<br>
  {<br>
  System.out.println(&quot; Reading from standard input . . .&quot;);<br>
  cparser = new CParser(System.in);<br>
  }<br>
  else if (args.length == 1)<br>
  {<br>
  System.out.println(&quot;Reading from file &quot; + args[0] + &quot; . . .&quot;);<br>
  try<br>
  {<br>
  cparser = new CParser(new java.io.FileInputStream(args[0]));<br>
  }<br>
  catch (java.io.FileNotFoundException e)<br>
  {<br>
  System.out.println(&quot;File &quot; + args[0] + &quot; not found.&quot;);<br>
  return;<br>
  }<br>
  }<br>
  else<br>
  {<br>
  System.out.println(&quot;Usage is one of:&quot;);<br>
  System.out.println(&quot;CParser &lt; inputfile&quot;);<br>
  System.out.println(&quot;OR&quot;);<br>
  System.out.println(&quot;CParser inputfile&quot;);<br>
  return;<br>
  }<br>
  try<br>
  {<br>
  cparser.doParse();<br>
  if(errcnt==0)<br>
  {<br>
  System.out.println(&quot;Program parsed successfully.&quot;);<br>
  dispCode(vec);<br>
  }<br>
  }</p>
<p> catch (ParseException e)<br>
  {<br>
  System.out.println(&quot;Encountered errors during parse.&quot;);<br>
  }<br>
  }</p>
<p> static void dispCode(Vector vec)<br>
  {<br>
  Enumeration vEnum = vec.elements();<br>
  System.out.println(&quot;\u005c\u005cnElements in vector:&quot;);<br>
  while(vEnum.hasMoreElements())<br>
  {<br>
  ic3a = (IC3A)vEnum.nextElement();<br>
  System.out.println(ic3a.label+&quot;\u005ct&quot;+ic3a.opcode + &quot;\u005ct&quot;  + ic3a.operand1.toString() +  &quot;\u005ct&quot; + ic3a.operand2.toString() + &quot;\u005ct&quot; + ic3a.lvalue + &quot;\u005cn&quot;);<br>
  System.out.println();<br>
  }<br>
  }</p>
<p> static final public void doParse() throws ParseException {<br>
  label_1:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case 103:<br>
  case 104:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[0] = jj_gen;<br>
  break label_1;<br>
  }<br>
  includeDeclaration();<br>
  }<br>
  label_2:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _char:<br>
  case _const:<br>
  case _double:<br>
  case _extern:<br>
  case _float:<br>
  case _int:<br>
  case _long:<br>
  case _register:<br>
  case _restrict:<br>
  case _short:<br>
  case _static:<br>
  case _typedef:<br>
  case _void:<br>
  case _volatile:<br>
  case _identifier:<br>
  case _semicolon:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[1] = jj_gen;<br>
  break label_2;<br>
  }<br>
  typeDeclaration();<br>
  }<br>
  jj_consume_token(0);<br>
  }</p>
<p> static final public void includeDeclaration() throws ParseException {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case 103:<br>
  jj_consume_token(103);<br>
  name();<br>
  jj_consume_token(_gt);<br>
  break;<br>
  case 104:<br>
  jj_consume_token(104);<br>
  name();<br>
  literal();<br>
  break;<br>
  default:<br>
  jj_la1[2] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }</p>
<p> static final public void typeDeclaration() throws ParseException {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _char:<br>
  case _const:<br>
  case _double:<br>
  case _extern:<br>
  case _float:<br>
  case _int:<br>
  case _long:<br>
  case _register:<br>
  case _restrict:<br>
  case _short:<br>
  case _static:<br>
  case _typedef:<br>
  case _void:<br>
  case _volatile:<br>
  case _identifier:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  functionBodyDeclaration();<br>
  break;<br>
  case _semicolon:<br>
  jj_consume_token(_semicolon);<br>
  break;<br>
  default:<br>
  jj_la1[3] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }</p>
<p> static final public void functionBodyDeclaration() throws ParseException {<br>
  if (jj_2_1(2)) {<br>
  staticInitializer();<br>
  } else if (jj_2_2(2147483647)) {<br>
  methodDeclaration();<br>
  } else {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _char:<br>
  case _const:<br>
  case _double:<br>
  case _extern:<br>
  case _float:<br>
  case _int:<br>
  case _long:<br>
  case _register:<br>
  case _restrict:<br>
  case _short:<br>
  case _static:<br>
  case _typedef:<br>
  case _volatile:<br>
  case _identifier:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  globalDeclaration();<br>
  symTab.dispSymbols();<br>
  break;<br>
  default:<br>
  jj_la1[4] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }<br>
  }</p>
<p> static final public void methodDeclarationLookahead() throws ParseException {<br>
  resultType();<br>
  jj_consume_token(_identifier);<br>
  jj_consume_token(_lparen);<br>
  }</p>
<p> static final public void globalDeclaration() throws ParseException {<br>
  Token n;Token n1;Type dtype;Symbol sym;int storage;int qualifier;<br>
  Symbol symbol;<br>
  storage=Constants.AUTO; qualifier=Constants.VOLATILE;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _extern:<br>
  case _register:<br>
  case _static:<br>
  case _typedef:<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  n = jj_consume_token(_auto);<br>
  storage=Constants.AUTO;<br>
  break;<br>
  case _register:<br>
  n = jj_consume_token(_register);<br>
  storage=Constants.REGISTER;<br>
  break;<br>
  case _static:<br>
  n = jj_consume_token(_static);<br>
  storage=Constants.STATIC;<br>
  break;<br>
  case _extern:<br>
  n = jj_consume_token(_extern);<br>
  storage=Constants.EXTERN;<br>
  break;<br>
  case _typedef:<br>
  n = jj_consume_token(_typedef);<br>
  storage=Constants.TYPEDEF;<br>
  break;<br>
  default:<br>
  jj_la1[5] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  break;<br>
  default:<br>
  jj_la1[6] = jj_gen;<br>
  ;<br>
  }<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _const:<br>
  case _restrict:<br>
  case _volatile:<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _const:<br>
  n1 = jj_consume_token(_const);<br>
  qualifier=Constants.CONSTANT;<br>
  break;<br>
  case _restrict:<br>
  n1 = jj_consume_token(_restrict);<br>
  qualifier=Constants.RESTRICT;<br>
  break;<br>
  case _volatile:<br>
  n1 = jj_consume_token(_volatile);<br>
  qualifier=Constants.VOLATILE;<br>
  break;<br>
  default:<br>
  jj_la1[7] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  break;<br>
  default:<br>
  jj_la1[8] = jj_gen;<br>
  ;<br>
  }<br>
  dtype = type();<br>
  System.out.println(dtype.subtype + &quot;.......&quot;);<br>
  sym = variableDeclarator();<br>
  symbol = new Symbol();<br>
  symbol.storage=storage;<br>
  symbol.qualifier=qualifier;<br>
  symbol.type=dtype;<br>
  switch(dtype.subtype)<br>
  {<br>
  case Constants.CHAR:<br>
  symbol.width=1;<br>
  break;<br>
  case Constants.INTEGER:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.FLOAT:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.DOUBLE:<br>
  symbol.width=8;<br>
  break;<br>
  default:<br>
  symbol.width=4;<br>
  }<br>
  symbol.name=sym.name;<br>
  symTab.hm.put(symbol.name, symbol);<br>
  label_3:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _comma:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[9] = jj_gen;<br>
  break label_3;<br>
  }<br>
  jj_consume_token(_comma);<br>
  sym = variableDeclarator();<br>
  symbol = new Symbol();<br>
  symbol.storage=storage;<br>
  symbol.qualifier=qualifier;<br>
  symbol.type=dtype;<br>
  switch(dtype.subtype)<br>
  {<br>
  case Constants.CHAR:<br>
  symbol.width=1;<br>
  break;<br>
  case Constants.INTEGER:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.FLOAT:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.DOUBLE:<br>
  symbol.width=8;<br>
  break;<br>
  default:<br>
  symbol.width=4;<br>
  }<br>
  symbol.name=sym.name;<br>
  symTab.hm.put(symbol.name, symbol);<br>
  }<br>
  jj_consume_token(_semicolon);<br>
  }</p>
<p> static final public Symbol variableDeclarator() throws ParseException {<br>
  Expression expr;String s;<br>
  Symbol symbol =new Symbol();<br>
  s = variableDeclaratorId();<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _assign:<br>
  jj_consume_token(_assign);<br>
  expr = variableInitializer();<br>
  symbol.sVal=expr.toString();<br>
  break;<br>
  default:<br>
  jj_la1[10] = jj_gen;<br>
  ;<br>
  }<br>
  symbol.name=s;<br>
  {if (true) return symbol;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public String variableDeclaratorId() throws ParseException {<br>
  Token n; String s;<br>
  n = jj_consume_token(_identifier);<br>
  s=n.toString();<br>
  label_4:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lbracket:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[11] = jj_gen;<br>
  break label_4;<br>
  }<br>
  jj_consume_token(_lbracket);<br>
  jj_consume_token(_rbracket);<br>
  s=s+&quot;[]&quot;;<br>
  }<br>
  {if (true) return s;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression variableInitializer() throws ParseException {<br>
  Expression expr;<br>
  expr = expression();<br>
  {if (true) return expr;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public void methodDeclaration() throws ParseException {<br>
  resultType();<br>
  methodDeclarator();<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lbrace:<br>
  block();<br>
  break;<br>
  case _semicolon:<br>
  jj_consume_token(_semicolon);<br>
  break;<br>
  default:<br>
  jj_la1[12] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }</p>
<p> static final public void methodDeclarator() throws ParseException {<br>
  jj_consume_token(_identifier);<br>
  formalParameters();<br>
  label_5:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lbracket:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[13] = jj_gen;<br>
  break label_5;<br>
  }<br>
  jj_consume_token(_lbracket);<br>
  jj_consume_token(_rbracket);<br>
  }<br>
  }</p>
<p> static final public void formalParameters() throws ParseException {<br>
  jj_consume_token(_lparen);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _char:<br>
  case _double:<br>
  case _float:<br>
  case _int:<br>
  case _long:<br>
  case _short:<br>
  case _identifier:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  formalParameter();<br>
  label_6:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _comma:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[14] = jj_gen;<br>
  break label_6;<br>
  }<br>
  jj_consume_token(_comma);<br>
  formalParameter();<br>
  }<br>
  break;<br>
  default:<br>
  jj_la1[15] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_rparen);<br>
  }</p>
<p> static final public void formalParameter() throws ParseException {<br>
  type();<br>
  variableDeclaratorId();<br>
  }</p>
<p> static final public void staticInitializer() throws ParseException {<br>
  jj_consume_token(_static);<br>
  block();<br>
  }</p>
<p> static final public Type type() throws ParseException {<br>
  int itype;String stype;<br>
  Type type = new Type();<br>
  type.dimensionCnt=0;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _char:<br>
  case _double:<br>
  case _float:<br>
  case _int:<br>
  case _long:<br>
  case _short:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  itype = primitiveType();<br>
  type.type = Constants.BASIC;<br>
  type.subtype = itype;<br>
  break;<br>
  case _identifier:<br>
  stype = name();<br>
  type.subtype = Constants.USERTYPE;<br>
  type.value = stype;<br>
  break;<br>
  default:<br>
  jj_la1[16] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  label_7:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lbracket:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[17] = jj_gen;<br>
  break label_7;<br>
  }<br>
  jj_consume_token(_lbracket);<br>
  jj_consume_token(_rbracket);<br>
  type.subtype = Constants.ARRAY;<br>
  type.dimensionCnt++;<br>
  }<br>
  {if (true) return type;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public int primitiveType() throws ParseException {<br>
  Token n;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _char:<br>
  n = jj_consume_token(_char);<br>
  {if (true) return Constants.CHAR;}<br>
  break;<br>
  case 105:<br>
  n = jj_consume_token(105);<br>
  {if (true) return Constants.UNSIGNEDCHAR;}<br>
  break;<br>
  case _int:<br>
  n = jj_consume_token(_int);<br>
  {if (true) return Constants.INTEGER;} ;<br>
  break;<br>
  case _short:<br>
  n = jj_consume_token(_short);<br>
  {if (true) return Constants.SHORT;}<br>
  break;<br>
  case 106:<br>
  n = jj_consume_token(106);<br>
  {if (true) return Constants.SHORTINT;}<br>
  break;<br>
  case _long:<br>
  n = jj_consume_token(_long);<br>
  {if (true) return Constants.LONG;}<br>
  break;<br>
  case 107:<br>
  n = jj_consume_token(107);<br>
  {if (true) return Constants.LONGINTEGER;}<br>
  break;<br>
  case _float:<br>
  n = jj_consume_token(_float);<br>
  {if (true) return Constants.FLOAT;}<br>
  break;<br>
  case _double:<br>
  n = jj_consume_token(_double);<br>
  {if (true) return Constants.DOUBLE;}<br>
  break;<br>
  default:<br>
  jj_la1[18] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Type resultType() throws ParseException {<br>
  Token n;Type typ;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _void:<br>
  typ = new Type();<br>
  n = jj_consume_token(_void);<br>
  typ.type=Constants.BASIC;<br>
  typ.subtype=Constants.VOID;<br>
  {if (true) return typ;}<br>
  break;<br>
  case _char:<br>
  case _double:<br>
  case _float:<br>
  case _int:<br>
  case _long:<br>
  case _short:<br>
  case _identifier:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  typ = type();<br>
  {if (true) return typ;}<br>
  break;<br>
  default:<br>
  jj_la1[19] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public String name() throws ParseException {<br>
  String s1;String s2;Token n1;Token n2;<br>
  n1 = jj_consume_token(_identifier);<br>
  s1=n1.toString();<br>
  label_8:<br>
  while (true) {<br>
  if (jj_2_3(2)) {<br>
  ;<br>
  } else {<br>
  break label_8;<br>
  }<br>
  jj_consume_token(_dot);<br>
  n2 = jj_consume_token(_identifier);<br>
  s2 = n2.toString();<br>
  s1 = s1 + &quot;.&quot; + s2;<br>
  }<br>
  {if (true) return s1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Vector nameList() throws ParseException {<br>
  Vector v;String s;<br>
  v = new Vector();<br>
  s = name();<br>
  v.addElement(s);<br>
  label_9:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _comma:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[20] = jj_gen;<br>
  break label_9;<br>
  }<br>
  jj_consume_token(_comma);<br>
  s = name();<br>
  v.addElement(s);<br>
  }<br>
  {if (true) return v;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression expression() throws ParseException {<br>
  Expression expr1;Expression expr2;Token s;IC3A ic3a;<br>
  if (jj_2_4(2147483647)) {<br>
  assignment();<br>
  expr1 = primaryExpression();<br>
  s = assignmentOperator();<br>
  expr2 = expression();<br>
  ic3a = new IC3A(labelpending,s.toString(),expr2,new _identifier(&quot; &quot;),expr1.toString());<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  } else {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _bang:<br>
  case _tilde:<br>
  case _incr:<br>
  case _decr:<br>
  case _plus:<br>
  case _minus:<br>
  expr1 = conditionalExpression();<br>
  {if (true) return expr1;}<br>
  break;<br>
  default:<br>
  jj_la1[21] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression assignment() throws ParseException {<br>
  Expression expr1;Expression expr2;Token s;IC3A ic3a;<br>
  expr1 = primaryExpression();<br>
  s = assignmentOperator();<br>
  expr2 = expression();<br>
  ic3a = new IC3A(labelpending,s.toString(),expr2,new _identifier(&quot; &quot;),expr1.toString());<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Token assignmentOperator() throws ParseException {<br>
  Token n;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _assign:<br>
  n = jj_consume_token(_assign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _starAssign:<br>
  n = jj_consume_token(_starAssign);<br>
  {if (true) return n ;}<br>
  break;<br>
  case _slashAssign:<br>
  n = jj_consume_token(_slashAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _remAssign:<br>
  n = jj_consume_token(_remAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _plusAssign:<br>
  n = jj_consume_token(_plusAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _minusAssign:<br>
  n = jj_consume_token(_minusAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _lShiftAssign:<br>
  n = jj_consume_token(_lShiftAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _rSignedShiftAssign:<br>
  n = jj_consume_token(_rSignedShiftAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _rUnsignedShiftAssign:<br>
  n = jj_consume_token(_rUnsignedShiftAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _andAssign:<br>
  n = jj_consume_token(_andAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _xorAssign:<br>
  n = jj_consume_token(_xorAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  case _orAssign:<br>
  n = jj_consume_token(_orAssign);<br>
  {if (true) return n;}<br>
  break;<br>
  default:<br>
  jj_la1[22] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression conditionalExpression() throws ParseException {<br>
  Expression expr;Expression expr1;Expression expr2;IC3A ic3a;String lvalue;<br>
  expr = conditionalOrExpression();<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _hook:<br>
  jj_consume_token(_hook);<br>
  expr1 = expression();<br>
  jj_consume_token(_colon);<br>
  expr2 = conditionalExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a=new IC3A(labelpending,&quot;?&quot;, expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return new _identifier(ic3a.lvalue);}<br>
  break;<br>
  default:<br>
  jj_la1[23] = jj_gen;<br>
  ;<br>
  }<br>
  {if (true) return expr;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression conditionalOrExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;IC3A ic3a;String lvalue;<br>
  expr1 = conditionalAndExpression();<br>
  label_10:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _scOr:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[24] = jj_gen;<br>
  break label_10;<br>
  }<br>
  jj_consume_token(_scOr);<br>
  expr2 = conditionalAndExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,&quot;||&quot;, expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression conditionalAndExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;IC3A ic3a;String lvalue;<br>
  expr1 = inclusiveOrExpression();<br>
  label_11:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _scAnd:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[25] = jj_gen;<br>
  break label_11;<br>
  }<br>
  jj_consume_token(_scAnd);<br>
  expr2 = inclusiveOrExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,&quot;&amp;&amp;&quot;, expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression inclusiveOrExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;IC3A ic3a;String lvalue;<br>
  expr1 = exclusiveOrExpression();<br>
  label_12:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _bitOr:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[26] = jj_gen;<br>
  break label_12;<br>
  }<br>
  jj_consume_token(_bitOr);<br>
  expr2 = exclusiveOrExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,&quot;|&quot;, expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression exclusiveOrExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;IC3A ic3a;String lvalue;<br>
  expr1 = andExpression();<br>
  label_13:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _xor:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[27] = jj_gen;<br>
  break label_13;<br>
  }<br>
  jj_consume_token(_xor);<br>
  expr2 = andExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,&quot;^&quot;, expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression andExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;IC3A ic3a;String lvalue;<br>
  expr1 = equalityExpression();<br>
  label_14:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _bitAnd:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[28] = jj_gen;<br>
  break label_14;<br>
  }<br>
  jj_consume_token(_bitAnd);<br>
  expr2 = equalityExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,&quot;&amp;&quot;, expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression equalityExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;Token n;IC3A ic3a;String lvalue;<br>
  expr1 = relationalExpression();<br>
  label_15:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _eq:<br>
  case _ne:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[29] = jj_gen;<br>
  break label_15;<br>
  }<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _eq:<br>
  n = jj_consume_token(_eq);<br>
  break;<br>
  case _ne:<br>
  n = jj_consume_token(_ne);<br>
  break;<br>
  default:<br>
  jj_la1[30] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  expr2 = relationalExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression relationalExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;Token n;IC3A ic3a;String lvalue;<br>
  expr1 = shiftExpression();<br>
  label_16:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _gt:<br>
  case _lt:<br>
  case _le:<br>
  case _ge:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[31] = jj_gen;<br>
  break label_16;<br>
  }<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lt:<br>
  n = jj_consume_token(_lt);<br>
  break;<br>
  case _gt:<br>
  n = jj_consume_token(_gt);<br>
  break;<br>
  case _le:<br>
  n = jj_consume_token(_le);<br>
  break;<br>
  case _ge:<br>
  n = jj_consume_token(_ge);<br>
  break;<br>
  default:<br>
  jj_la1[32] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  expr2 = shiftExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression shiftExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;Token n;IC3A ic3a;String lvalue;<br>
  expr1 = additiveExpression();<br>
  label_17:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lShift:<br>
  case _rSignedShift:<br>
  case _rUnsignedShift:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[33] = jj_gen;<br>
  break label_17;<br>
  }<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lShift:<br>
  n = jj_consume_token(_lShift);<br>
  break;<br>
  case _rSignedShift:<br>
  n = jj_consume_token(_rSignedShift);<br>
  break;<br>
  case _rUnsignedShift:<br>
  n = jj_consume_token(_rUnsignedShift);<br>
  break;<br>
  default:<br>
  jj_la1[34] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  expr2 = additiveExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, expr2,lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression additiveExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;Token n;IC3A ic3a;String lvalue;<br>
  expr1 = multiplicativeExpression();<br>
  label_18:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _plus:<br>
  case _minus:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[35] = jj_gen;<br>
  break label_18;<br>
  }<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _plus:<br>
  n = jj_consume_token(_plus);<br>
  break;<br>
  case _minus:<br>
  n = jj_consume_token(_minus);<br>
  break;<br>
  default:<br>
  jj_la1[36] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  expr2 = multiplicativeExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, expr2,lvalue);<br>
  expr1 = new _identifier(ic3a.lvalue);<br>
  vec.addElement(ic3a);<br>
  //return  new _identifier(ic3a.lvalue);</p>
<p> }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression multiplicativeExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;Token n;IC3A ic3a;String lvalue;<br>
  expr1 = unaryExpression();<br>
  label_19:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _star:<br>
  case _slash:<br>
  case _rem:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[37] = jj_gen;<br>
  break label_19;<br>
  }<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _star:<br>
  n = jj_consume_token(_star);<br>
  break;<br>
  case _slash:<br>
  n = jj_consume_token(_slash);<br>
  break;<br>
  case _rem:<br>
  n = jj_consume_token(_rem);<br>
  break;<br>
  default:<br>
  jj_la1[38] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  expr2 = unaryExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, expr2,lvalue);<br>
  expr1 = new _identifier(ic3a.lvalue);<br>
  vec.addElement(ic3a);<br>
  //return  new _identifier(ic3a.lvalue);</p>
<p> }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression unaryExpression() throws ParseException {<br>
  Expression expr;Token n;IC3A ic3a;String lvalue;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _plus:<br>
  case _minus:<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _plus:<br>
  n = jj_consume_token(_plus);<br>
  break;<br>
  case _minus:<br>
  n = jj_consume_token(_minus);<br>
  break;<br>
  default:<br>
  jj_la1[39] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  expr = unaryExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr, new _stringLiteral(&quot;unary&quot;),lvalue);<br>
  expr = new _identifier(ic3a.lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  expr;}//new _identifier(ic3a.lvalue);</p>
<p> break;<br>
  case _incr:<br>
  expr = preIncrementExpression();<br>
  {if (true) return expr;}<br>
  break;<br>
  case _decr:<br>
  expr = preDecrementExpression();<br>
  {if (true) return expr;}<br>
  break;<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _bang:<br>
  case _tilde:<br>
  expr = unaryExpressionNotPlusMinus();<br>
  {if (true) return expr;}<br>
  break;<br>
  default:<br>
  jj_la1[40] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression preIncrementExpression() throws ParseException {<br>
  Expression expr; Token n;IC3A ic3a;String lvalue;<br>
  n = jj_consume_token(_incr);<br>
  expr = primaryExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr, new _stringLiteral(&quot;prefix&quot;),lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression preDecrementExpression() throws ParseException {<br>
  Expression expr1;IC3A ic3a; Token n;String lvalue;<br>
  n = jj_consume_token(_decr);<br>
  expr1 = primaryExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, new _stringLiteral(&quot;prefix&quot;),lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression unaryExpressionNotPlusMinus() throws ParseException {<br>
  Expression expr;IC3A ic3a; Token n;String lvalue;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _bang:<br>
  case _tilde:<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _tilde:<br>
  n = jj_consume_token(_tilde);<br>
  break;<br>
  case _bang:<br>
  n = jj_consume_token(_bang);<br>
  break;<br>
  default:<br>
  jj_la1[41] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  expr = unaryExpression();<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr, new _stringLiteral(&quot;unary&quot;),lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  break;<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  expr = postfixExpression();<br>
  {if (true) return expr;}<br>
  break;<br>
  default:<br>
  jj_la1[42] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression postfixExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;IC3A ic3a; Token n;String lvalue;<br>
  expr1 = primaryExpression();<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _incr:<br>
  case _decr:<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _incr:<br>
  n = jj_consume_token(_incr);<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, new _stringLiteral(&quot;postfix&quot;),lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  break;<br>
  case _decr:<br>
  n = jj_consume_token(_decr);<br>
  tcnt=tcnt+1;<br>
  lvalue = &quot;t&quot; + tcnt;<br>
  ic3a = new IC3A(labelpending,n.toString(), expr1, new _stringLiteral(&quot;postfix&quot;),lvalue);<br>
  vec.addElement(ic3a);<br>
  {if (true) return  new _identifier(ic3a.lvalue);}<br>
  break;<br>
  default:<br>
  jj_la1[43] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  break;<br>
  default:<br>
  jj_la1[44] = jj_gen;<br>
  ;<br>
  }<br>
  {if (true) return expr1;}<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression primaryExpression() throws ParseException {<br>
  Expression expr;String s;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  expr = literal();<br>
  {if (true) return expr;}<br>
  break;<br>
  case _identifier:<br>
  s = name();<br>
  expr = new _identifier(s);<br>
  {<br>
  ctSymTab = symTab;<br>
  boolean found = false;<br>
  while(ctSymTab != null)<br>
  {<br>
  if(ctSymTab.hm.containsKey(s))<br>
  {<br>
  found = true;<br>
  break;<br>
  }<br>
  else<br>
  ctSymTab = ctSymTab.prevTab;<br>
  }<br>
  if(found == false)<br>
  {<br>
  System.out.println(s + &quot;is undeclared identifier\u005cn&quot; );<br>
  }<br>
  }<br>
  {if (true) return expr;}<br>
  break;<br>
  case _lparen:<br>
  jj_consume_token(_lparen);<br>
  expr = expression();<br>
  jj_consume_token(_rparen);<br>
  {if (true) return expr;}<br>
  break;<br>
  default:<br>
  jj_la1[45] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public Expression literal() throws ParseException {<br>
  Token n;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  n = jj_consume_token(_integerLiteral);<br>
  {if (true) return new _integerLiteral(Integer.parseInt(n.image));}<br>
  break;<br>
  case _floatingPointLiteral:<br>
  n = jj_consume_token(_floatingPointLiteral);<br>
  {if (true) return new _floatingPointLiteral(Double.parseDouble(n.image));}<br>
  break;<br>
  case _stringLiteral:<br>
  n = jj_consume_token(_stringLiteral);<br>
  {if (true) return new _stringLiteral(n.image);}<br>
  break;<br>
  default:<br>
  jj_la1[46] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public void arguments() throws ParseException {<br>
  jj_consume_token(_lparen);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _bang:<br>
  case _tilde:<br>
  case _incr:<br>
  case _decr:<br>
  case _plus:<br>
  case _minus:<br>
  argumentList();<br>
  break;<br>
  default:<br>
  jj_la1[47] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_rparen);<br>
  }</p>
<p> static final public void argumentList() throws ParseException {<br>
  expression();<br>
  label_20:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _comma:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[48] = jj_gen;<br>
  break label_20;<br>
  }<br>
  jj_consume_token(_comma);<br>
  expression();<br>
  }<br>
  }</p>
<p> static final public void arrayDimensions() throws ParseException {<br>
  label_21:<br>
  while (true) {<br>
  jj_consume_token(_lbracket);<br>
  expression();<br>
  jj_consume_token(_rbracket);<br>
  if (jj_2_5(2)) {<br>
  ;<br>
  } else {<br>
  break label_21;<br>
  }<br>
  }<br>
  label_22:<br>
  while (true) {<br>
  if (jj_2_6(2)) {<br>
  ;<br>
  } else {<br>
  break label_22;<br>
  }<br>
  jj_consume_token(_lbracket);<br>
  jj_consume_token(_rbracket);<br>
  }<br>
  }</p>
<p> static final public void statement() throws ParseException {<br>
  if (jj_2_7(2)) {<br>
  labeledStatement();<br>
  } else {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _lbrace:<br>
  block();<br>
  break;<br>
  case _semicolon:<br>
  emptyStatement();<br>
  break;<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _incr:<br>
  case _decr:<br>
  statementExpression();<br>
  jj_consume_token(_semicolon);<br>
  break;<br>
  case _switch:<br>
  switchStatement();<br>
  break;<br>
  case _if:<br>
  ifStatement();<br>
  break;<br>
  case _while:<br>
  whileStatement();<br>
  break;<br>
  case _do:<br>
  doStatement();<br>
  break;<br>
  case _for:<br>
  forStatement();<br>
  break;<br>
  case _break:<br>
  breakStatement();<br>
  break;<br>
  case _continue:<br>
  continueStatement();<br>
  break;<br>
  case _return:<br>
  returnStatement();<br>
  break;<br>
  default:<br>
  jj_la1[49] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }<br>
  }</p>
<p> static final public void labeledStatement() throws ParseException {<br>
  jj_consume_token(_identifier);<br>
  jj_consume_token(_colon);<br>
  statement();<br>
  }</p>
<p> static final public void block() throws ParseException {<br>
  jj_consume_token(_lbrace);<br>
  prevsymTab = symTab;<br>
  symTab = new SymTab();<br>
  symTab.structLink = null;<br>
  symTab.hm = new HashMap();<br>
  symTab.prevTab = prevsymTab;<br>
  label_23:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _break:<br>
  case _char:<br>
  case _const:<br>
  case _continue:<br>
  case _do:<br>
  case _double:<br>
  case _extern:<br>
  case _float:<br>
  case _for:<br>
  case _if:<br>
  case _int:<br>
  case _long:<br>
  case _register:<br>
  case _restrict:<br>
  case _return:<br>
  case _short:<br>
  case _static:<br>
  case _switch:<br>
  case _typedef:<br>
  case _volatile:<br>
  case _while:<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _lbrace:<br>
  case _semicolon:<br>
  case _incr:<br>
  case _decr:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[50] = jj_gen;<br>
  break label_23;<br>
  }<br>
  blockStatement();<br>
  }<br>
  jj_consume_token(_rbrace);<br>
  symTab.dispSymbols();<br>
  symTab = symTab.prevTab;<br>
  }</p>
<p> static final public void blockStatement() throws ParseException {<br>
  if (jj_2_8(2147483647)) {<br>
  localVariableDeclaration();<br>
  jj_consume_token(_semicolon);<br>
  } else {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _break:<br>
  case _continue:<br>
  case _do:<br>
  case _for:<br>
  case _if:<br>
  case _return:<br>
  case _switch:<br>
  case _while:<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _lbrace:<br>
  case _semicolon:<br>
  case _incr:<br>
  case _decr:<br>
  statement();<br>
  break;<br>
  default:<br>
  jj_la1[51] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }<br>
  }</p>
<p> static final public void localVariableDeclaration() throws ParseException {<br>
  Token n;Token n1;Type dtype;Symbol sym;int storage;int qualifier;<br>
  Symbol symbol;<br>
  storage=Constants.AUTO; qualifier=Constants.VOLATILE;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _extern:<br>
  case _register:<br>
  case _static:<br>
  case _typedef:<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  n = jj_consume_token(_auto);<br>
  storage=Constants.AUTO;<br>
  break;<br>
  case _register:<br>
  n = jj_consume_token(_register);<br>
  storage=Constants.REGISTER;<br>
  break;<br>
  case _static:<br>
  n = jj_consume_token(_static);<br>
  storage=Constants.STATIC;<br>
  break;<br>
  case _extern:<br>
  n = jj_consume_token(_extern);<br>
  storage=Constants.EXTERN;<br>
  break;<br>
  case _typedef:<br>
  n = jj_consume_token(_typedef);<br>
  storage=Constants.TYPEDEF;<br>
  break;<br>
  default:<br>
  jj_la1[52] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  break;<br>
  default:<br>
  jj_la1[53] = jj_gen;<br>
  ;<br>
  }<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _const:<br>
  case _restrict:<br>
  case _volatile:<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _const:<br>
  n1 = jj_consume_token(_const);<br>
  qualifier=Constants.CONSTANT;<br>
  break;<br>
  case _restrict:<br>
  n1 = jj_consume_token(_restrict);<br>
  qualifier=Constants.RESTRICT;<br>
  break;<br>
  case _volatile:<br>
  n1 = jj_consume_token(_volatile);<br>
  qualifier=Constants.VOLATILE;<br>
  break;<br>
  default:<br>
  jj_la1[54] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  break;<br>
  default:<br>
  jj_la1[55] = jj_gen;<br>
  ;<br>
  }<br>
  dtype = type();<br>
  sym = variableDeclarator();<br>
  symbol = new Symbol();<br>
  symbol.storage=storage;<br>
  symbol.qualifier=qualifier;<br>
  symbol.type=dtype;<br>
  switch(dtype.subtype)<br>
  {<br>
  case Constants.CHAR:<br>
  symbol.width=1;<br>
  break;<br>
  case Constants.INTEGER:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.FLOAT:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.DOUBLE:<br>
  symbol.width=8;<br>
  break;<br>
  default:<br>
  symbol.width=4;<br>
  }<br>
  symbol.name=sym.name;<br>
  symTab.hm.put(symbol.name, symbol);<br>
  label_24:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _comma:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[56] = jj_gen;<br>
  break label_24;<br>
  }<br>
  jj_consume_token(_comma);<br>
  sym = variableDeclarator();<br>
  symbol = new Symbol();<br>
  symbol.storage=storage;<br>
  symbol.qualifier=qualifier;<br>
  symbol.type=dtype;<br>
  switch(dtype.subtype)<br>
  {<br>
  case Constants.CHAR:<br>
  symbol.width=1;<br>
  break;<br>
  case Constants.INTEGER:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.FLOAT:<br>
  symbol.width=4;<br>
  break;<br>
  case Constants.DOUBLE:<br>
  symbol.width=8;<br>
  break;<br>
  default:<br>
  symbol.width=4;<br>
  }<br>
  symbol.name=sym.name;<br>
  symTab.hm.put(symbol.name, symbol);<br>
  }<br>
  }</p>
<p> static final public void emptyStatement() throws ParseException {<br>
  jj_consume_token(_semicolon);<br>
  }</p>
<p> static final public Expression statementExpression() throws ParseException {<br>
  Expression expr1;Expression expr2;IC3A ic3a;String s;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _incr:<br>
  expr1 = preIncrementExpression();<br>
  {if (true) return expr1;}<br>
  break;<br>
  case _decr:<br>
  expr1 = preDecrementExpression();<br>
  {if (true) return expr1;}<br>
  break;<br>
  default:<br>
  jj_la1[57] = jj_gen;<br>
  if (jj_2_9(2147483647)) {<br>
  expr1 = assignment();<br>
  {if (true) return expr1;}<br>
  } else {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  expr1 = postfixExpression();<br>
  {if (true) return expr1;}<br>
  break;<br>
  default:<br>
  jj_la1[58] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }<br>
  }<br>
  throw new Error(&quot;Missing return statement in function&quot;);<br>
  }</p>
<p> static final public void ifStatement() throws ParseException {<br>
  String labelElse;String labelEndif;Expression expr;IC3A ic3a;Expression texpr;<br>
  jj_consume_token(_if);<br>
  jj_consume_token(_lparen);<br>
  lcnt=lcnt+1;<br>
  labelElse = &quot;L&quot; + lcnt;<br>
  expr = expression();<br>
  jj_consume_token(_rparen);<br>
  texpr =  new _integerLiteral(Integer.parseInt(&quot;0&quot;));</p>
<p> ic3a = new IC3A(labelpending,&quot;IFGO&quot;, expr, texpr,labelElse);<br>
  vec.addElement(ic3a);<br>
  statement();<br>
  labelpending = labelElse;<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _else:<br>
  jj_consume_token(_else);<br>
  lcnt=lcnt+1;<br>
  labelEndif = &quot;L&quot; + lcnt;<br>
  expr = new _identifier(&quot; &quot;);<br>
  texpr = new _identifier(&quot; &quot;);<br>
  ic3a = new IC3A(&quot; &quot;,&quot;GOTO&quot;, expr, texpr,labelEndif);<br>
  vec.addElement(ic3a);<br>
  labelpending = labelElse;<br>
  statement();<br>
  labelpending = labelEndif;<br>
  break;<br>
  default:<br>
  jj_la1[59] = jj_gen;<br>
  ;<br>
  }<br>
  }</p>
<p> static final public void switchStatement() throws ParseException {<br>
  jj_consume_token(_switch);<br>
  jj_consume_token(_lparen);<br>
  expression();<br>
  jj_consume_token(_rparen);<br>
  jj_consume_token(_lbrace);<br>
  label_25:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _case:<br>
  case _default:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[60] = jj_gen;<br>
  break label_25;<br>
  }<br>
  switchLabel();<br>
  label_26:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _break:<br>
  case _char:<br>
  case _const:<br>
  case _continue:<br>
  case _do:<br>
  case _double:<br>
  case _extern:<br>
  case _float:<br>
  case _for:<br>
  case _if:<br>
  case _int:<br>
  case _long:<br>
  case _register:<br>
  case _restrict:<br>
  case _return:<br>
  case _short:<br>
  case _static:<br>
  case _switch:<br>
  case _typedef:<br>
  case _volatile:<br>
  case _while:<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _lbrace:<br>
  case _semicolon:<br>
  case _incr:<br>
  case _decr:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[61] = jj_gen;<br>
  break label_26;<br>
  }<br>
  blockStatement();<br>
  }<br>
  }<br>
  jj_consume_token(_rbrace);<br>
  }</p>
<p> static final public void switchLabel() throws ParseException {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _case:<br>
  jj_consume_token(_case);<br>
  expression();<br>
  jj_consume_token(_colon);<br>
  break;<br>
  case _default:<br>
  jj_consume_token(_default);<br>
  jj_consume_token(_colon);<br>
  break;<br>
  default:<br>
  jj_la1[62] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }</p>
<p> static final public void whileStatement() throws ParseException {<br>
  String labelWhileBegin; String labelWhileEnd;Expression expr;Expression texpr;IC3A ic3a;<br>
  jj_consume_token(_while);<br>
  jj_consume_token(_lparen);<br>
  lcnt=lcnt+1;<br>
  labelWhileBegin = &quot;L&quot; + lcnt;<br>
  lcnt=lcnt+1;<br>
  labelWhileEnd = &quot;L&quot; + lcnt;<br>
  labelpending = labelWhileBegin;<br>
  expr = expression();<br>
  jj_consume_token(_rparen);<br>
  texpr =  new _integerLiteral(Integer.parseInt(&quot;0&quot;));<br>
  ic3a = new IC3A(&quot; &quot;,&quot;IFGO&quot;, expr, texpr,labelWhileEnd);<br>
  vec.addElement(ic3a);<br>
  statement();<br>
  expr = new _identifier(&quot; &quot;);<br>
  texpr = new _identifier(&quot; &quot;);<br>
  ic3a = new IC3A(labelpending,&quot;GOTO&quot;, expr, texpr,labelWhileBegin);<br>
  vec.addElement(ic3a);<br>
  labelpending = labelWhileEnd;<br>
  }</p>
<p> static final public void doStatement() throws ParseException {<br>
  jj_consume_token(_do);<br>
  statement();<br>
  jj_consume_token(_while);<br>
  jj_consume_token(_lparen);<br>
  expression();<br>
  jj_consume_token(_rparen);<br>
  jj_consume_token(_semicolon);<br>
  }</p>
<p> static final public void forStatement() throws ParseException {<br>
  jj_consume_token(_for);<br>
  jj_consume_token(_lparen);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _auto:<br>
  case _char:<br>
  case _const:<br>
  case _double:<br>
  case _extern:<br>
  case _float:<br>
  case _int:<br>
  case _long:<br>
  case _register:<br>
  case _restrict:<br>
  case _short:<br>
  case _static:<br>
  case _typedef:<br>
  case _volatile:<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _incr:<br>
  case _decr:<br>
  case 105:<br>
  case 106:<br>
  case 107:<br>
  forInit();<br>
  break;<br>
  default:<br>
  jj_la1[63] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_semicolon);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _bang:<br>
  case _tilde:<br>
  case _incr:<br>
  case _decr:<br>
  case _plus:<br>
  case _minus:<br>
  expression();<br>
  break;<br>
  default:<br>
  jj_la1[64] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_semicolon);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _incr:<br>
  case _decr:<br>
  forUpdate();<br>
  break;<br>
  default:<br>
  jj_la1[65] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_rparen);<br>
  statement();<br>
  }</p>
<p> static final public void forInit() throws ParseException {<br>
  if (jj_2_10(2147483647)) {<br>
  localVariableDeclaration();<br>
  } else {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _incr:<br>
  case _decr:<br>
  statementExpressionList();<br>
  break;<br>
  default:<br>
  jj_la1[66] = jj_gen;<br>
  jj_consume_token(-1);<br>
  throw new ParseException();<br>
  }<br>
  }<br>
  }</p>
<p> static final public void statementExpressionList() throws ParseException {<br>
  statementExpression();<br>
  label_27:<br>
  while (true) {<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _comma:<br>
  ;<br>
  break;<br>
  default:<br>
  jj_la1[67] = jj_gen;<br>
  break label_27;<br>
  }<br>
  jj_consume_token(_comma);<br>
  statementExpression();<br>
  }<br>
  }</p>
<p> static final public void forUpdate() throws ParseException {<br>
  statementExpressionList();<br>
  }</p>
<p> static final public void breakStatement() throws ParseException {<br>
  jj_consume_token(_break);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _identifier:<br>
  jj_consume_token(_identifier);<br>
  break;<br>
  default:<br>
  jj_la1[68] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_semicolon);<br>
  }</p>
<p> static final public void continueStatement() throws ParseException {<br>
  jj_consume_token(_continue);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _identifier:<br>
  jj_consume_token(_identifier);<br>
  break;<br>
  default:<br>
  jj_la1[69] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_semicolon);<br>
  }</p>
<p> static final public void returnStatement() throws ParseException {<br>
  jj_consume_token(_return);<br>
  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {<br>
  case _integerLiteral:<br>
  case _floatingPointLiteral:<br>
  case _stringLiteral:<br>
  case _identifier:<br>
  case _lparen:<br>
  case _bang:<br>
  case _tilde:<br>
  case _incr:<br>
  case _decr:<br>
  case _plus:<br>
  case _minus:<br>
  expression();<br>
  break;<br>
  default:<br>
  jj_la1[70] = jj_gen;<br>
  ;<br>
  }<br>
  jj_consume_token(_semicolon);<br>
  }</p>
<p> static private boolean jj_2_1(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_1(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(0, xla); }<br>
  }</p>
<p> static private boolean jj_2_2(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_2(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(1, xla); }<br>
  }</p>
<p> static private boolean jj_2_3(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_3(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(2, xla); }<br>
  }</p>
<p> static private boolean jj_2_4(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_4(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(3, xla); }<br>
  }</p>
<p> static private boolean jj_2_5(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_5(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(4, xla); }<br>
  }</p>
<p> static private boolean jj_2_6(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_6(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(5, xla); }<br>
  }</p>
<p> static private boolean jj_2_7(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_7(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(6, xla); }<br>
  }</p>
<p> static private boolean jj_2_8(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_8(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(7, xla); }<br>
  }</p>
<p> static private boolean jj_2_9(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_9(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(8, xla); }<br>
  }</p>
<p> static private boolean jj_2_10(int xla) {<br>
  jj_la = xla; jj_lastpos = jj_scanpos = token;<br>
  try { return !jj_3_10(); }<br>
  catch(LookaheadSuccess ls) { return true; }<br>
  finally { jj_save(9, xla); }<br>
  }</p>
<p> static private boolean jj_3R_105() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_scan_token(70)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(69)) return true;<br>
  }<br>
  if (jj_3R_95()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_104() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_105()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_106()) return true;<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_82() {<br>
  if (jj_scan_token(_scAnd)) return true;<br>
  if (jj_3R_79()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_103() {<br>
  if (jj_scan_token(_decr)) return true;<br>
  if (jj_3R_30()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_77() {<br>
  if (jj_3R_79()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_82()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_102() {<br>
  if (jj_scan_token(_incr)) return true;<br>
  if (jj_3R_30()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_80() {<br>
  if (jj_scan_token(_scOr)) return true;<br>
  if (jj_3R_77()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_100() {<br>
  if (jj_3R_104()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_67() {<br>
  if (jj_3R_77()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_80()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_99() {<br>
  if (jj_3R_103()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_98() {<br>
  if (jj_3R_102()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_8() {<br>
  if (jj_3R_34()) return true;<br>
  if (jj_scan_token(_identifier)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_10() {<br>
  if (jj_3R_34()) return true;<br>
  if (jj_scan_token(_identifier)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_78() {<br>
  if (jj_scan_token(_hook)) return true;<br>
  if (jj_3R_32()) return true;<br>
  if (jj_scan_token(_colon)) return true;<br>
  if (jj_3R_62()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_62() {<br>
  if (jj_3R_67()) return true;<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_78()) jj_scanpos = xsp;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_97() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_scan_token(81)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(82)) return true;<br>
  }<br>
  if (jj_3R_95()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_95() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_97()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_98()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_99()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_100()) return true;<br>
  }<br>
  }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_51() {<br>
  if (jj_scan_token(_orAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_50() {<br>
  if (jj_scan_token(_xorAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_49() {<br>
  if (jj_scan_token(_andAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_48() {<br>
  if (jj_scan_token(_rUnsignedShiftAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_47() {<br>
  if (jj_scan_token(_rSignedShiftAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_46() {<br>
  if (jj_scan_token(_lShiftAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_45() {<br>
  if (jj_scan_token(_minusAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_6() {<br>
  if (jj_scan_token(_lbracket)) return true;<br>
  if (jj_scan_token(_rbracket)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_44() {<br>
  if (jj_scan_token(_plusAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_43() {<br>
  if (jj_scan_token(_remAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_42() {<br>
  if (jj_scan_token(_slashAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_41() {<br>
  if (jj_scan_token(_starAssign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_40() {<br>
  if (jj_scan_token(_assign)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_31() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_40()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_41()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_42()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_43()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_44()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_45()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_46()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_47()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_48()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_49()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_50()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_51()) return true;<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_101() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_scan_token(83)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(84)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(88)) return true;<br>
  }<br>
  }<br>
  if (jj_3R_95()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_93() {<br>
  if (jj_3R_95()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_101()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_35() {<br>
  if (jj_scan_token(_lbrace)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_53() {<br>
  if (jj_3R_62()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_61() {<br>
  if (jj_3R_30()) return true;<br>
  if (jj_3R_31()) return true;<br>
  if (jj_3R_32()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_33() {<br>
  if (jj_scan_token(_identifier)) return true;<br>
  if (jj_scan_token(_colon)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_4() {<br>
  if (jj_3R_30()) return true;<br>
  if (jj_3R_31()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_96() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_scan_token(81)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(82)) return true;<br>
  }<br>
  if (jj_3R_93()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_91() {<br>
  if (jj_3R_93()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_96()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_52() {<br>
  if (jj_3R_61()) return true;<br>
  if (jj_3R_30()) return true;<br>
  if (jj_3R_31()) return true;<br>
  if (jj_3R_32()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_32() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_52()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_53()) return true;<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_7() {<br>
  if (jj_3R_33()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_5() {<br>
  if (jj_scan_token(_lbracket)) return true;<br>
  if (jj_3R_32()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_94() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_scan_token(89)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(90)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(91)) return true;<br>
  }<br>
  }<br>
  if (jj_3R_91()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_89() {<br>
  if (jj_3R_91()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_94()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_66() {<br>
  if (jj_scan_token(_stringLiteral)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_92() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_scan_token(68)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(67)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(74)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(75)) return true;<br>
  }<br>
  }<br>
  }<br>
  if (jj_3R_89()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_3() {<br>
  if (jj_scan_token(_dot)) return true;<br>
  if (jj_scan_token(_identifier)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_87() {<br>
  if (jj_3R_89()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_92()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_65() {<br>
  if (jj_scan_token(_floatingPointLiteral)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_58() {<br>
  if (jj_3R_34()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_60() {<br>
  if (jj_scan_token(_identifier)) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3_3()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_59() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_64()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_65()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_66()) return true;<br>
  }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_64() {<br>
  if (jj_scan_token(_integerLiteral)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_2() {<br>
  if (jj_3R_29()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_39() {<br>
  if (jj_scan_token(_lparen)) return true;<br>
  if (jj_3R_32()) return true;<br>
  if (jj_scan_token(_rparen)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_90() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_scan_token(73)) {<br>
  jj_scanpos = xsp;<br>
  if (jj_scan_token(76)) return true;<br>
  }<br>
  if (jj_3R_87()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_36() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_57()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_58()) return true;<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_57() {<br>
  if (jj_scan_token(_void)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_85() {<br>
  if (jj_3R_87()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_90()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_9() {<br>
  if (jj_3R_30()) return true;<br>
  if (jj_3R_31()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_76() {<br>
  if (jj_scan_token(_double)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_29() {<br>
  if (jj_3R_36()) return true;<br>
  if (jj_scan_token(_identifier)) return true;<br>
  if (jj_scan_token(_lparen)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_75() {<br>
  if (jj_scan_token(_float)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_74() {<br>
  if (jj_scan_token(107)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_73() {<br>
  if (jj_scan_token(_long)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_72() {<br>
  if (jj_scan_token(106)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3_1() {<br>
  if (jj_3R_28()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_71() {<br>
  if (jj_scan_token(_short)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_70() {<br>
  if (jj_scan_token(_int)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_69() {<br>
  if (jj_scan_token(105)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_63() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_68()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_69()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_70()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_71()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_72()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_73()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_74()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_75()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_76()) return true;<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_68() {<br>
  if (jj_scan_token(_char)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_88() {<br>
  if (jj_scan_token(_bitAnd)) return true;<br>
  if (jj_3R_85()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_83() {<br>
  if (jj_3R_85()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_88()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_38() {<br>
  if (jj_3R_60()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_37() {<br>
  if (jj_3R_59()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_30() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_37()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_38()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_39()) return true;<br>
  }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_56() {<br>
  if (jj_scan_token(_lbracket)) return true;<br>
  if (jj_scan_token(_rbracket)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_55() {<br>
  if (jj_3R_60()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_86() {<br>
  if (jj_scan_token(_xor)) return true;<br>
  if (jj_3R_83()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_110() {<br>
  if (jj_scan_token(_decr)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_81() {<br>
  if (jj_3R_83()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_86()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_54() {<br>
  if (jj_3R_63()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_109() {<br>
  if (jj_scan_token(_incr)) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_108() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_109()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_110()) return true;<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_34() {<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_54()) {<br>
  jj_scanpos = xsp;<br>
  if (jj_3R_55()) return true;<br>
  }<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_56()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_107() {<br>
  if (jj_3R_30()) return true;<br>
  Token xsp;<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_108()) jj_scanpos = xsp;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_28() {<br>
  if (jj_scan_token(_static)) return true;<br>
  if (jj_3R_35()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_84() {<br>
  if (jj_scan_token(_bitOr)) return true;<br>
  if (jj_3R_81()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_79() {<br>
  if (jj_3R_81()) return true;<br>
  Token xsp;<br>
  while (true) {<br>
  xsp = jj_scanpos;<br>
  if (jj_3R_84()) { jj_scanpos = xsp; break; }<br>
  }<br>
  return false;<br>
  }</p>
<p> static private boolean jj_3R_106() {<br>
  if (jj_3R_107()) return true;<br>
  return false;<br>
  }</p>
<p> static private boolean jj_initialized_once = false;<br>
  /** Generated Token Manager. */<br>
  static public CParserTokenManager token_source;<br>
  static JavaCharStream jj_input_stream;<br>
  /** Current token. */<br>
  static public Token token;<br>
  /** Next token. */<br>
  static public Token jj_nt;<br>
  static private int jj_ntk;<br>
  static private Token jj_scanpos, jj_lastpos;<br>
  static private int jj_la;<br>
  static private int jj_gen;<br>
  static final private int[] jj_la1 = new int[71];<br>
  static private int[] jj_la1_0;<br>
  static private int[] jj_la1_1;<br>
  static private int[] jj_la1_2;<br>
  static private int[] jj_la1_3;<br>
  static {<br>
  jj_la1_init_0();<br>
  jj_la1_init_1();<br>
  jj_la1_init_2();<br>
  jj_la1_init_3();<br>
  }<br>
  private static void jj_la1_init_0() {<br>
  jj_la1_0 = new int[] {0x0,0x78323200,0x0,0x78323200,0x78323200,0x20100200,0x20100200,0x40002000,0x40002000,0x0,0x0,0x0,0x0,0x0,0x0,0x18221000,0x18221000,0x0,0x18221000,0x18221000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x81414400,0xf9737600,0x81414400,0x20100200,0x20100200,0x40002000,0x40002000,0x0,0x0,0x0,0x40000,0x8800,0xf9737600,0x8800,0x78323200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};<br>
  }<br>
  private static void jj_la1_init_1() {<br>
  jj_la1_1 = new int[] {0x0,0x80400649,0x0,0x80400649,0x400449,0x48,0x48,0x400,0x400,0x0,0x0,0x20000000,0x88000000,0x20000000,0x0,0x400001,0x400001,0x20000000,0x1,0x400201,0x0,0x2688000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2688000,0x0,0x2688000,0x0,0x0,0x2688000,0x288000,0x2688000,0x0,0x8a688820,0x8a688c69,0x8a688820,0x48,0x48,0x400,0x400,0x0,0x0,0x2688000,0x0,0x0,0x8a688c69,0x0,0x2688449,0x2688000,0x2688000,0x2688000,0x0,0x400000,0x400000,0x2688000,};<br>
  }<br>
  private static void jj_la1_init_2() {<br>
  jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x4,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x78060,0xf0000004,0x80,0x2000,0x4000,0x400000,0x800000,0x200000,0x1200,0x1200,0xc18,0xc18,0xe000000,0xe000000,0x60000,0x60000,0x1180000,0x1180000,0x60000,0x78060,0x60,0x60,0x18000,0x18000,0x0,0x0,0x78060,0x1,0x18000,0x18000,0x18000,0x0,0x0,0x0,0x0,0x1,0x18000,0x0,0x0,0x0,0x18000,0x0,0x18000,0x78060,0x18000,0x18000,0x1,0x0,0x0,0x78060,};<br>
  }<br>
  private static void jj_la1_init_3() {<br>
  jj_la1_3 = new int[] {0x180,0xe00,0x180,0xe00,0xe00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe00,0xe00,0x0,0xe00,0xe00,0x0,0x0,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe00,0x0,0xe00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};<br>
  }<br>
  static final private JJCalls[] jj_2_rtns = new JJCalls[10];<br>
  static private boolean jj_rescan = false;<br>
  static private int jj_gc = 0;</p>
<p> /** Constructor with InputStream. */<br>
  public CParser(java.io.InputStream stream) {<br>
  this(stream, null);<br>
  }<br>
  /** Constructor with InputStream and supplied encoding */<br>
  public CParser(java.io.InputStream stream, String encoding) {<br>
  if (jj_initialized_once) {<br>
  System.out.println(&quot;ERROR: Second call to constructor of static parser.  &quot;);<br>
  System.out.println(&quot;       You must either use ReInit() or set the JavaCC option STATIC to false&quot;);<br>
  System.out.println(&quot;       during parser generation.&quot;);<br>
  throw new Error();<br>
  }<br>
  jj_initialized_once = true;<br>
  try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }<br>
  token_source = new CParserTokenManager(jj_input_stream);<br>
  token = new Token();<br>
  jj_ntk = -1;<br>
  jj_gen = 0;<br>
  for (int i = 0; i &lt; 71; i++) jj_la1[i] = -1;<br>
  for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();<br>
  }</p>
<p> /** Reinitialise. */<br>
  static public void ReInit(java.io.InputStream stream) {<br>
  ReInit(stream, null);<br>
  }<br>
  /** Reinitialise. */<br>
  static public void ReInit(java.io.InputStream stream, String encoding) {<br>
  try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }<br>
  token_source.ReInit(jj_input_stream);<br>
  token = new Token();<br>
  jj_ntk = -1;<br>
  jj_gen = 0;<br>
  for (int i = 0; i &lt; 71; i++) jj_la1[i] = -1;<br>
  for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();<br>
  }</p>
<p> /** Constructor. */<br>
  public CParser(java.io.Reader stream) {<br>
  if (jj_initialized_once) {<br>
  System.out.println(&quot;ERROR: Second call to constructor of static parser. &quot;);<br>
  System.out.println(&quot;       You must either use ReInit() or set the JavaCC option STATIC to false&quot;);<br>
  System.out.println(&quot;       during parser generation.&quot;);<br>
  throw new Error();<br>
  }<br>
  jj_initialized_once = true;<br>
  jj_input_stream = new JavaCharStream(stream, 1, 1);<br>
  token_source = new CParserTokenManager(jj_input_stream);<br>
  token = new Token();<br>
  jj_ntk = -1;<br>
  jj_gen = 0;<br>
  for (int i = 0; i &lt; 71; i++) jj_la1[i] = -1;<br>
  for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();<br>
  }</p>
<p> /** Reinitialise. */<br>
  static public void ReInit(java.io.Reader stream) {<br>
  jj_input_stream.ReInit(stream, 1, 1);<br>
  token_source.ReInit(jj_input_stream);<br>
  token = new Token();<br>
  jj_ntk = -1;<br>
  jj_gen = 0;<br>
  for (int i = 0; i &lt; 71; i++) jj_la1[i] = -1;<br>
  for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();<br>
  }</p>
<p> /** Constructor with generated Token Manager. */<br>
  public CParser(CParserTokenManager tm) {<br>
  if (jj_initialized_once) {<br>
  System.out.println(&quot;ERROR: Second call to constructor of static parser. &quot;);<br>
  System.out.println(&quot;       You must either use ReInit() or set the JavaCC option STATIC to false&quot;);<br>
  System.out.println(&quot;       during parser generation.&quot;);<br>
  throw new Error();<br>
  }<br>
  jj_initialized_once = true;<br>
  token_source = tm;<br>
  token = new Token();<br>
  jj_ntk = -1;<br>
  jj_gen = 0;<br>
  for (int i = 0; i &lt; 71; i++) jj_la1[i] = -1;<br>
  for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();<br>
  }</p>
<p> /** Reinitialise. */<br>
  public void ReInit(CParserTokenManager tm) {<br>
  token_source = tm;<br>
  token = new Token();<br>
  jj_ntk = -1;<br>
  jj_gen = 0;<br>
  for (int i = 0; i &lt; 71; i++) jj_la1[i] = -1;<br>
  for (int i = 0; i &lt; jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();<br>
  }</p>
<p> static private Token jj_consume_token(int kind) throws ParseException {<br>
  Token oldToken;<br>
  if ((oldToken = token).next != null) token = token.next;<br>
  else token = token.next = token_source.getNextToken();<br>
  jj_ntk = -1;<br>
  if (token.kind == kind) {<br>
  jj_gen++;<br>
  if (++jj_gc &gt; 100) {<br>
  jj_gc = 0;<br>
  for (int i = 0; i &lt; jj_2_rtns.length; i++) {<br>
  JJCalls c = jj_2_rtns[i];<br>
  while (c != null) {<br>
  if (c.gen &lt; jj_gen) c.first = null;<br>
  c = c.next;<br>
  }<br>
  }<br>
  }<br>
  return token;<br>
  }<br>
  token = oldToken;<br>
  jj_kind = kind;<br>
  throw generateParseException();<br>
  }</p>
<p> static private final class LookaheadSuccess extends java.lang.Error { }<br>
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();<br>
  static private boolean jj_scan_token(int kind) {<br>
  if (jj_scanpos == jj_lastpos) {<br>
  jj_la--;<br>
  if (jj_scanpos.next == null) {<br>
  jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();<br>
  } else {<br>
  jj_lastpos = jj_scanpos = jj_scanpos.next;<br>
  }<br>
  } else {<br>
  jj_scanpos = jj_scanpos.next;<br>
  }<br>
  if (jj_rescan) {<br>
  int i = 0; Token tok = token;<br>
  while (tok != null &amp;&amp; tok != jj_scanpos) { i++; tok = tok.next; }<br>
  if (tok != null) jj_add_error_token(kind, i);<br>
  }<br>
  if (jj_scanpos.kind != kind) return true;<br>
  if (jj_la == 0 &amp;&amp; jj_scanpos == jj_lastpos) throw jj_ls;<br>
  return false;<br>
  }<br>
</p>
<p>/** Get the next Token. */<br>
  static final public Token getNextToken() {<br>
  if (token.next != null) token = token.next;<br>
  else token = token.next = token_source.getNextToken();<br>
  jj_ntk = -1;<br>
  jj_gen++;<br>
  return token;<br>
  }</p>
<p>/** Get the specific Token. */<br>
  static final public Token getToken(int index) {<br>
  Token t = token;<br>
  for (int i = 0; i &lt; index; i++) {<br>
  if (t.next != null) t = t.next;<br>
  else t = t.next = token_source.getNextToken();<br>
  }<br>
  return t;<br>
  }</p>
<p> static private int jj_ntk() {<br>
  if ((jj_nt=token.next) == null)<br>
  return (jj_ntk = (token.next=token_source.getNextToken()).kind);<br>
  else<br>
  return (jj_ntk = jj_nt.kind);<br>
  }</p>
<p> static private java.util.List&lt;int[]&gt; jj_expentries = new java.util.ArrayList&lt;int[]&gt;();<br>
  static private int[] jj_expentry;<br>
  static private int jj_kind = -1;<br>
  static private int[] jj_lasttokens = new int[100];<br>
  static private int jj_endpos;</p>
<p> static private void jj_add_error_token(int kind, int pos) {<br>
  if (pos &gt;= 100) return;<br>
  if (pos == jj_endpos + 1) {<br>
  jj_lasttokens[jj_endpos++] = kind;<br>
  } else if (jj_endpos != 0) {<br>
  jj_expentry = new int[jj_endpos];<br>
  for (int i = 0; i &lt; jj_endpos; i++) {<br>
  jj_expentry[i] = jj_lasttokens[i];<br>
  }<br>
  jj_entries_loop: for (java.util.Iterator&lt;?&gt; it = jj_expentries.iterator(); it.hasNext();) {<br>
  int[] oldentry = (int[])(it.next());<br>
  if (oldentry.length == jj_expentry.length) {<br>
  for (int i = 0; i &lt; jj_expentry.length; i++) {<br>
  if (oldentry[i] != jj_expentry[i]) {<br>
  continue jj_entries_loop;<br>
  }<br>
  }<br>
  jj_expentries.add(jj_expentry);<br>
  break jj_entries_loop;<br>
  }<br>
  }<br>
  if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;<br>
  }<br>
  }</p>
<p> /** Generate ParseException. */<br>
  static public ParseException generateParseException() {<br>
  jj_expentries.clear();<br>
  boolean[] la1tokens = new boolean[108];<br>
  if (jj_kind &gt;= 0) {<br>
  la1tokens[jj_kind] = true;<br>
  jj_kind = -1;<br>
  }<br>
  for (int i = 0; i &lt; 71; i++) {<br>
  if (jj_la1[i] == jj_gen) {<br>
  for (int j = 0; j &lt; 32; j++) {<br>
  if ((jj_la1_0[i] &amp; (1&lt;&lt;j)) != 0) {<br>
  la1tokens[j] = true;<br>
  }<br>
  if ((jj_la1_1[i] &amp; (1&lt;&lt;j)) != 0) {<br>
  la1tokens[32+j] = true;<br>
  }<br>
  if ((jj_la1_2[i] &amp; (1&lt;&lt;j)) != 0) {<br>
  la1tokens[64+j] = true;<br>
  }<br>
  if ((jj_la1_3[i] &amp; (1&lt;&lt;j)) != 0) {<br>
  la1tokens[96+j] = true;<br>
  }<br>
  }<br>
  }<br>
  }<br>
  for (int i = 0; i &lt; 108; i++) {<br>
  if (la1tokens[i]) {<br>
  jj_expentry = new int[1];<br>
  jj_expentry[0] = i;<br>
  jj_expentries.add(jj_expentry);<br>
  }<br>
  }<br>
  jj_endpos = 0;<br>
  jj_rescan_token();<br>
  jj_add_error_token(0, 0);<br>
  int[][] exptokseq = new int[jj_expentries.size()][];<br>
  for (int i = 0; i &lt; jj_expentries.size(); i++) {<br>
  exptokseq[i] = jj_expentries.get(i);<br>
  }<br>
  return new ParseException(token, exptokseq, tokenImage);<br>
  }</p>
<p> /** Enable tracing. */<br>
  static final public void enable_tracing() {<br>
  }</p>
<p> /** Disable tracing. */<br>
  static final public void disable_tracing() {<br>
  }</p>
<p> static private void jj_rescan_token() {<br>
  jj_rescan = true;<br>
  for (int i = 0; i &lt; 10; i++) {<br>
  try {<br>
  JJCalls p = jj_2_rtns[i];<br>
  do {<br>
  if (p.gen &gt; jj_gen) {<br>
  jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;<br>
  switch (i) {<br>
  case 0: jj_3_1(); break;<br>
  case 1: jj_3_2(); break;<br>
  case 2: jj_3_3(); break;<br>
  case 3: jj_3_4(); break;<br>
  case 4: jj_3_5(); break;<br>
  case 5: jj_3_6(); break;<br>
  case 6: jj_3_7(); break;<br>
  case 7: jj_3_8(); break;<br>
  case 8: jj_3_9(); break;<br>
  case 9: jj_3_10(); break;<br>
  }<br>
  }<br>
  p = p.next;<br>
  } while (p != null);<br>
  } catch(LookaheadSuccess ls) { }<br>
  }<br>
  jj_rescan = false;<br>
  }</p>
<p> static private void jj_save(int index, int xla) {<br>
  JJCalls p = jj_2_rtns[index];<br>
  while (p.gen &gt; jj_gen) {<br>
  if (p.next == null) { p = p.next = new JJCalls(); break; }<br>
  p = p.next;<br>
  }<br>
  p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;<br>
  }</p>
<p> static final class JJCalls {<br>
  int gen;<br>
  Token first;<br>
  int arg;<br>
  JJCalls next;<br>
  }</p>
<p> }<br>
</p>
<p><br>
</p>
</body>
</html>