<html>
<head>
</head>
<body bgcolor="#CCCCCC">
<h2 align="center">Source Code - JavaCharStream.java</h2>
<p>/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 5.0 */<br>
  /* JavaCCOptions:STATIC=true,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */<br>
  /**<br>
* An implementation of interface CharStream, where the stream is assumed to<br>
* contain only ASCII characters (with java-like unicode escape processing).<br>
*/</p>
<p>public class JavaCharStream<br>
  {<br>
  /** Whether parser is static. */<br>
  public static final boolean staticFlag = true;</p>
<p> static final int hexval(char c) throws java.io.IOException {<br>
  switch(c)<br>
  {<br>
  case '0' :<br>
  return 0;<br>
  case '1' :<br>
  return 1;<br>
  case '2' :<br>
  return 2;<br>
  case '3' :<br>
  return 3;<br>
  case '4' :<br>
  return 4;<br>
  case '5' :<br>
  return 5;<br>
  case '6' :<br>
  return 6;<br>
  case '7' :<br>
  return 7;<br>
  case '8' :<br>
  return 8;<br>
  case '9' :<br>
  return 9;</p>
<p> case 'a' :<br>
  case 'A' :<br>
  return 10;<br>
  case 'b' :<br>
  case 'B' :<br>
  return 11;<br>
  case 'c' :<br>
  case 'C' :<br>
  return 12;<br>
  case 'd' :<br>
  case 'D' :<br>
  return 13;<br>
  case 'e' :<br>
  case 'E' :<br>
  return 14;<br>
  case 'f' :<br>
  case 'F' :<br>
  return 15;<br>
  }</p>
<p> throw new java.io.IOException(); // Should never come here<br>
  }</p>
<p>/** Position in buffer. */<br>
  static public int bufpos = -1;<br>
  static int bufsize;<br>
  static int available;<br>
  static int tokenBegin;<br>
  static protected int bufline[];<br>
  static protected int bufcolumn[];</p>
<p> static protected int column = 0;<br>
  static protected int line = 1;</p>
<p> static protected boolean prevCharIsCR = false;<br>
  static protected boolean prevCharIsLF = false;</p>
<p> static protected java.io.Reader inputStream;</p>
<p> static protected char[] nextCharBuf;<br>
  static protected char[] buffer;<br>
  static protected int maxNextCharInd = 0;<br>
  static protected int nextCharInd = -1;<br>
  static protected int inBuf = 0;<br>
  static protected int tabSize = 8;</p>
<p> static protected void setTabSize(int i) { tabSize = i; }<br>
  static protected int getTabSize(int i) { return tabSize; }</p>
<p> static protected void ExpandBuff(boolean wrapAround)<br>
  {<br>
  char[] newbuffer = new char[bufsize + 2048];<br>
  int newbufline[] = new int[bufsize + 2048];<br>
  int newbufcolumn[] = new int[bufsize + 2048];</p>
<p> try<br>
  {<br>
  if (wrapAround)<br>
  {<br>
  System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);<br>
  System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);<br>
  buffer = newbuffer;</p>
<p> System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);<br>
  System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);<br>
  bufline = newbufline;</p>
<p> System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);<br>
  System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);<br>
  bufcolumn = newbufcolumn;</p>
<p> bufpos += (bufsize - tokenBegin);<br>
  }<br>
  else<br>
  {<br>
  System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);<br>
  buffer = newbuffer;</p>
<p> System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);<br>
  bufline = newbufline;</p>
<p> System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);<br>
  bufcolumn = newbufcolumn;</p>
<p> bufpos -= tokenBegin;<br>
  }<br>
  }<br>
  catch (Throwable t)<br>
  {<br>
  throw new Error(t.getMessage());<br>
  }</p>
<p> available = (bufsize += 2048);<br>
  tokenBegin = 0;<br>
  }</p>
<p> static protected void FillBuff() throws java.io.IOException<br>
  {<br>
  int i;<br>
  if (maxNextCharInd == 4096)<br>
  maxNextCharInd = nextCharInd = 0;</p>
<p> try {<br>
  if ((i = inputStream.read(nextCharBuf, maxNextCharInd,<br>
  4096 - maxNextCharInd)) == -1)<br>
  {<br>
  inputStream.close();<br>
  throw new java.io.IOException();<br>
  }<br>
  else<br>
  maxNextCharInd += i;<br>
  return;<br>
  }<br>
  catch(java.io.IOException e) {<br>
  if (bufpos != 0)<br>
  {<br>
  --bufpos;<br>
  backup(0);<br>
  }<br>
  else<br>
  {<br>
  bufline[bufpos] = line;<br>
  bufcolumn[bufpos] = column;<br>
  }<br>
  throw e;<br>
  }<br>
  }</p>
<p> static protected char ReadByte() throws java.io.IOException<br>
  {<br>
  if (++nextCharInd &gt;= maxNextCharInd)<br>
  FillBuff();</p>
<p> return nextCharBuf[nextCharInd];<br>
  }</p>
<p>/** @return starting character for token. */<br>
  static public char BeginToken() throws java.io.IOException<br>
  {<br>
  if (inBuf &gt; 0)<br>
  {<br>
  --inBuf;</p>
<p> if (++bufpos == bufsize)<br>
  bufpos = 0;</p>
<p> tokenBegin = bufpos;<br>
  return buffer[bufpos];<br>
  }</p>
<p> tokenBegin = 0;<br>
  bufpos = -1;</p>
<p> return readChar();<br>
  }</p>
<p> static protected void AdjustBuffSize()<br>
  {<br>
  if (available == bufsize)<br>
  {<br>
  if (tokenBegin &gt; 2048)<br>
  {<br>
  bufpos = 0;<br>
  available = tokenBegin;<br>
  }<br>
  else<br>
  ExpandBuff(false);<br>
  }<br>
  else if (available &gt; tokenBegin)<br>
  available = bufsize;<br>
  else if ((tokenBegin - available) &lt; 2048)<br>
  ExpandBuff(true);<br>
  else<br>
  available = tokenBegin;<br>
  }</p>
<p> static protected void UpdateLineColumn(char c)<br>
  {<br>
  column++;</p>
<p> if (prevCharIsLF)<br>
  {<br>
  prevCharIsLF = false;<br>
  line += (column = 1);<br>
  }<br>
  else if (prevCharIsCR)<br>
  {<br>
  prevCharIsCR = false;<br>
  if (c == '\n')<br>
  {<br>
  prevCharIsLF = true;<br>
  }<br>
  else<br>
  line += (column = 1);<br>
  }</p>
<p> switch (c)<br>
  {<br>
  case '\r' :<br>
  prevCharIsCR = true;<br>
  break;<br>
  case '\n' :<br>
  prevCharIsLF = true;<br>
  break;<br>
  case '\t' :<br>
  column--;<br>
  column += (tabSize - (column % tabSize));<br>
  break;<br>
  default :<br>
  break;<br>
  }</p>
<p> bufline[bufpos] = line;<br>
  bufcolumn[bufpos] = column;<br>
  }</p>
<p>/** Read a character. */<br>
  static public char readChar() throws java.io.IOException<br>
  {<br>
  if (inBuf &gt; 0)<br>
  {<br>
  --inBuf;</p>
<p> if (++bufpos == bufsize)<br>
  bufpos = 0;</p>
<p> return buffer[bufpos];<br>
  }</p>
<p> char c;</p>
<p> if (++bufpos == available)<br>
  AdjustBuffSize();</p>
<p> if ((buffer[bufpos] = c = ReadByte()) == '\\')<br>
  {<br>
  UpdateLineColumn(c);</p>
<p> int backSlashCnt = 1;</p>
<p> for (;;) // Read all the backslashes<br>
  {<br>
  if (++bufpos == available)<br>
  AdjustBuffSize();</p>
<p> try<br>
  {<br>
  if ((buffer[bufpos] = c = ReadByte()) != '\\')<br>
  {<br>
  UpdateLineColumn(c);<br>
  // found a non-backslash char.<br>
  if ((c == 'u') &amp;&amp; ((backSlashCnt &amp; 1) == 1))<br>
  {<br>
  if (--bufpos &lt; 0)<br>
  bufpos = bufsize - 1;</p>
<p> break;<br>
  }</p>
<p> backup(backSlashCnt);<br>
  return '\\';<br>
  }<br>
  }<br>
  catch(java.io.IOException e)<br>
  {<br>
  // We are returning one backslash so we should only backup (count-1)<br>
  if (backSlashCnt &gt; 1)<br>
  backup(backSlashCnt-1);</p>
<p> return '\\';<br>
  }</p>
<p> UpdateLineColumn(c);<br>
  backSlashCnt++;<br>
  }</p>
<p> // Here, we have seen an odd number of backslash's followed by a 'u'<br>
  try<br>
  {<br>
  while ((c = ReadByte()) == 'u')<br>
  ++column;</p>
<p> buffer[bufpos] = c = (char)(hexval(c) &lt;&lt; 12 |<br>
  hexval(ReadByte()) &lt;&lt; 8 |<br>
  hexval(ReadByte()) &lt;&lt; 4 |<br>
  hexval(ReadByte()));</p>
<p> column += 4;<br>
  }<br>
  catch(java.io.IOException e)<br>
  {<br>
  throw new Error(&quot;Invalid escape character at line &quot; + line +<br>
  &quot; column &quot; + column + &quot;.&quot;);<br>
  }</p>
<p> if (backSlashCnt == 1)<br>
  return c;<br>
  else<br>
  {<br>
  backup(backSlashCnt - 1);<br>
  return '\\';<br>
  }<br>
  }<br>
  else<br>
  {<br>
  UpdateLineColumn(c);<br>
  return c;<br>
  }<br>
  }</p>
<p> @Deprecated<br>
  /**<br>
  * @deprecated<br>
  * @see #getEndColumn<br>
  */<br>
  static public int getColumn() {<br>
  return bufcolumn[bufpos];<br>
  }</p>
<p> @Deprecated<br>
  /**<br>
  * @deprecated<br>
  * @see #getEndLine<br>
  */<br>
  static public int getLine() {<br>
  return bufline[bufpos];<br>
  }</p>
<p>/** Get end column. */<br>
  static public int getEndColumn() {<br>
  return bufcolumn[bufpos];<br>
  }</p>
<p>/** Get end line. */<br>
  static public int getEndLine() {<br>
  return bufline[bufpos];<br>
  }</p>
<p>/** @return column of token start */<br>
  static public int getBeginColumn() {<br>
  return bufcolumn[tokenBegin];<br>
  }</p>
<p>/** @return line number of token start */<br>
  static public int getBeginLine() {<br>
  return bufline[tokenBegin];<br>
  }</p>
<p>/** Retreat. */<br>
  static public void backup(int amount) {</p>
<p> inBuf += amount;<br>
  if ((bufpos -= amount) &lt; 0)<br>
  bufpos += bufsize;<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.Reader dstream,<br>
  int startline, int startcolumn, int buffersize)<br>
  {<br>
  if (inputStream != null)<br>
  throw new Error(&quot;\n   ERROR: Second call to the constructor of a static JavaCharStream.\n&quot; +<br>
  &quot;       You must either use ReInit() or set the JavaCC option STATIC to false\n&quot; +<br>
  &quot;       during the generation of this class.&quot;);<br>
  inputStream = dstream;<br>
  line = startline;<br>
  column = startcolumn - 1;</p>
<p> available = bufsize = buffersize;<br>
  buffer = new char[buffersize];<br>
  bufline = new int[buffersize];<br>
  bufcolumn = new int[buffersize];<br>
  nextCharBuf = new char[4096];<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.Reader dstream,<br>
  int startline, int startcolumn)<br>
  {<br>
  this(dstream, startline, startcolumn, 4096);<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.Reader dstream)<br>
  {<br>
  this(dstream, 1, 1, 4096);<br>
  }<br>
  /** Reinitialise. */<br>
  public void ReInit(java.io.Reader dstream,<br>
  int startline, int startcolumn, int buffersize)<br>
  {<br>
  inputStream = dstream;<br>
  line = startline;<br>
  column = startcolumn - 1;</p>
<p> if (buffer == null || buffersize != buffer.length)<br>
  {<br>
  available = bufsize = buffersize;<br>
  buffer = new char[buffersize];<br>
  bufline = new int[buffersize];<br>
  bufcolumn = new int[buffersize];<br>
  nextCharBuf = new char[4096];<br>
  }<br>
  prevCharIsLF = prevCharIsCR = false;<br>
  tokenBegin = inBuf = maxNextCharInd = 0;<br>
  nextCharInd = bufpos = -1;<br>
  }</p>
<p>/** Reinitialise. */<br>
  public void ReInit(java.io.Reader dstream,<br>
  int startline, int startcolumn)<br>
  {<br>
  ReInit(dstream, startline, startcolumn, 4096);<br>
  }</p>
<p>/** Reinitialise. */<br>
  public void ReInit(java.io.Reader dstream)<br>
  {<br>
  ReInit(dstream, 1, 1, 4096);<br>
  }<br>
  /** Constructor. */<br>
  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,<br>
  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException<br>
  {<br>
  this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.InputStream dstream, int startline,<br>
  int startcolumn, int buffersize)<br>
  {<br>
  this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,<br>
  int startcolumn) throws java.io.UnsupportedEncodingException<br>
  {<br>
  this(dstream, encoding, startline, startcolumn, 4096);<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.InputStream dstream, int startline,<br>
  int startcolumn)<br>
  {<br>
  this(dstream, startline, startcolumn, 4096);<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException<br>
  {<br>
  this(dstream, encoding, 1, 1, 4096);<br>
  }</p>
<p>/** Constructor. */<br>
  public JavaCharStream(java.io.InputStream dstream)<br>
  {<br>
  this(dstream, 1, 1, 4096);<br>
  }</p>
<p>/** Reinitialise. */<br>
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,<br>
  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException<br>
  {<br>
  ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);<br>
  }</p>
<p>/** Reinitialise. */<br>
  public void ReInit(java.io.InputStream dstream, int startline,<br>
  int startcolumn, int buffersize)<br>
  {<br>
  ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);<br>
  }<br>
  /** Reinitialise. */<br>
  public void ReInit(java.io.InputStream dstream, String encoding, int startline,<br>
  int startcolumn) throws java.io.UnsupportedEncodingException<br>
  {<br>
  ReInit(dstream, encoding, startline, startcolumn, 4096);<br>
  }<br>
  /** Reinitialise. */<br>
  public void ReInit(java.io.InputStream dstream, int startline,<br>
  int startcolumn)<br>
  {<br>
  ReInit(dstream, startline, startcolumn, 4096);<br>
  }<br>
  /** Reinitialise. */<br>
  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException<br>
  {<br>
  ReInit(dstream, encoding, 1, 1, 4096);<br>
  }</p>
<p>/** Reinitialise. */<br>
  public void ReInit(java.io.InputStream dstream)<br>
  {<br>
  ReInit(dstream, 1, 1, 4096);<br>
  }</p>
<p> /** @return token image as String */<br>
  static public String GetImage()<br>
  {<br>
  if (bufpos &gt;= tokenBegin)<br>
  return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);<br>
  else<br>
  return new String(buffer, tokenBegin, bufsize - tokenBegin) +<br>
  new String(buffer, 0, bufpos + 1);<br>
  }</p>
<p> /** @return suffix */<br>
  static public char[] GetSuffix(int len)<br>
  {<br>
  char[] ret = new char[len];</p>
<p> if ((bufpos + 1) &gt;= len)<br>
  System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);<br>
  else<br>
  {<br>
  System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,<br>
  len - bufpos - 1);<br>
  System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);<br>
  }</p>
<p> return ret;<br>
  }</p>
<p> /** Set buffers back to null when finished. */<br>
  static public void Done()<br>
  {<br>
  nextCharBuf = null;<br>
  buffer = null;<br>
  bufline = null;<br>
  bufcolumn = null;<br>
  }</p>
<p> /**<br>
  * Method to adjust line and column numbers for the start of a token.<br>
  */<br>
  static public void adjustBeginLineColumn(int newLine, int newCol)<br>
  {<br>
  int start = tokenBegin;<br>
  int len;</p>
<p> if (bufpos &gt;= tokenBegin)<br>
  {<br>
  len = bufpos - tokenBegin + inBuf + 1;<br>
  }<br>
  else<br>
  {<br>
  len = bufsize - tokenBegin + bufpos + 1 + inBuf;<br>
  }</p>
<p> int i = 0, j = 0, k = 0;<br>
  int nextColDiff = 0, columnDiff = 0;</p>
<p> while (i &lt; len &amp;&amp; bufline[j = start % bufsize] == bufline[k = ++start % bufsize])<br>
  {<br>
  bufline[j] = newLine;<br>
  nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];<br>
  bufcolumn[j] = newCol + columnDiff;<br>
  columnDiff = nextColDiff;<br>
  i++;<br>
  }</p>
<p> if (i &lt; len)<br>
  {<br>
  bufline[j] = newLine++;<br>
  bufcolumn[j] = newCol + columnDiff;</p>
<p> while (i++ &lt; len)<br>
  {<br>
  if (bufline[j = start % bufsize] != bufline[++start % bufsize])<br>
  bufline[j] = newLine++;<br>
  else<br>
  bufline[j] = newLine;<br>
  }<br>
  }</p>
<p> line = bufline[j];<br>
  column = bufcolumn[j];<br>
  }</p>
<p>}<br>
  /* JavaCC - OriginalChecksum=e3598d1f8d80fbc270dd435d3ccdc67b (do not edit this line) */<br>
</p>
<p><br>
</p>
</body>
</html>